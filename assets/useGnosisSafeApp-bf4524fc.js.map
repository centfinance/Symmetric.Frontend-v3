{"version":3,"file":"useGnosisSafeApp-bf4524fc.js","sources":["../../src/plugins/router/nav-guards.ts","../../src/composables/useApp.ts","../../src/composables/useGnosisSafeApp.ts"],"sourcesContent":["import { ref } from 'vue';\nimport {\n  getRedirectUrlFor,\n  handleNetworkSlug,\n  networkFromSlug,\n  networkSlug,\n} from '@/composables/useNetwork';\nimport { isJoinsDisabled } from '@/composables/usePoolHelpers';\nimport config from '@/lib/config';\nimport { Network } from '@/lib/config/types';\nimport { Router } from 'vue-router';\nimport metaService from '@/services/meta/meta.service';\nimport { votingRequest } from '@/components/contextual/pages/vebal/providers/voting.provider';\n\n/**\n * State\n */\nconst redirecting = ref(false);\n\n/**\n * Navigation guards\n */\nexport function applyNavGuards(router: Router): Router {\n  router = applyNetworkSubdomainRedirect(router);\n  router = applyNetworkPathRedirects(router);\n  router = applyPoolJoinRedirects(router);\n  router = applyMetaData(router);\n  router = applyVotingRedirects(router);\n\n  return router;\n}\n\n/**\n * Full page refresh redirect to given URL.\n *\n * @param {string} url - URL to redirect to.\n * @param {Router} router - vue-router.\n */\nexport function hardRedirectTo(url: string) {\n  redirecting.value = true;\n  document.body.style.display = 'none';\n  window.location.href = url;\n  location.reload();\n}\n\n/**\n * Checks current URL for legacy network as subdomain URL and redirects to\n * app.balancer.fi if required.\n *\n * e.g. https://polygon.balancer.fi -> https://app.balancer.fi/#/polygon\n */\nfunction applyNetworkSubdomainRedirect(router: Router): Router {\n  router.beforeEach((to, from, next) => {\n    const redirectUrl = getRedirectUrlFor(\n      window.location.host,\n      to.redirectedFrom?.fullPath ?? to.fullPath,\n      to.params\n    );\n\n    if (redirectUrl) window.location.href = redirectUrl;\n    else next();\n  });\n\n  return router;\n}\n\n/**\n * Assuming the domain is correct, e.g. applyNetworkSubdomainRedirect() has not\n * triggered a redirect, check if the URL path is using the old format and\n * redirect if required.\n *\n * Requirements for a redirect:\n * - If the network is in the path, does it match the current app state? If not\n *   we should redirect to sync path with app state.\n * - If the current route is a redirect and the the path is one that requires a\n *   network slug, update the route to include the network slug.\n *\n * Note: We can assume the domain is correct because applyNetworkSubdomainRedirect() is\n * run before this function, see applyNavGuards().\n */\nfunction applyNetworkPathRedirects(router: Router): Router {\n  router.beforeEach((to, from, next) => {\n    if (redirecting.value) {\n      next();\n    } else {\n      const networkSlugFromUrl = to.params.networkSlug?.toString() ?? '';\n      const networkFromPath = networkFromSlug(networkSlugFromUrl);\n\n      if (networkFromPath) {\n        const noNetworkChangeCallback = () => next();\n        const networkChangeCallback = () => {\n          hardRedirectTo(`/#${to.fullPath}`);\n        };\n\n        handleNetworkSlug(\n          networkSlugFromUrl,\n          noNetworkChangeCallback,\n          networkChangeCallback\n        );\n      } else {\n        const networkAgnosticRoutes = [\n          '/',\n          '/terms-of-use',\n          '/privacy-policy',\n          '/cookies-policy',\n          '/risks',\n        ];\n        const routerHandledRedirects = ['not-found', 'trade-redirect'];\n        if (\n          to.redirectedFrom?.fullPath &&\n          to.redirectedFrom?.fullPath.includes('/pool')\n        ) {\n          const newPath = to.redirectedFrom?.fullPath ?? to.fullPath;\n          router.push({\n            path: `/${config[Network.TELOSTESTNET].slug}${newPath}`,\n          });\n        } else if (\n          !to.redirectedFrom ||\n          routerHandledRedirects.includes(to.redirectedFrom?.name as string) ||\n          networkAgnosticRoutes.includes(to.fullPath)\n        ) {\n          next();\n        } else {\n          const newPath = to.redirectedFrom?.fullPath ?? to.fullPath;\n          const newNetwork = newPath.includes('/pool')\n            ? config[Network.TELOSTESTNET].slug\n            : networkSlug;\n          router.push({ path: `/${newNetwork}${newPath}` });\n        }\n      }\n    }\n  });\n\n  return router;\n}\n\n/**\n * If the route is a pool invest page check if this should be accessible against\n * our isJoinsDisabled conditional. If so, redirect to the pool page.\n */\nfunction applyPoolJoinRedirects(router: Router): Router {\n  router.beforeEach((to, from, next) => {\n    if (\n      to.name === 'add-liquidity' &&\n      isJoinsDisabled(to.params?.id as string)\n    ) {\n      next({\n        name: 'pool',\n        params: to.params,\n      });\n    } else next();\n  });\n  return router;\n}\n\nfunction applyMetaData(router: Router): Router {\n  router.beforeEach((to, from, next) => {\n    // Pool meta data is handled in the pool page\n    if (to.name === 'pool') {\n      next();\n      return;\n    }\n    metaService.setMeta(to);\n    next();\n  });\n  return router;\n}\n\n/**\n * Redirect to the voting list when trying to open voting page without pools selected for voting.\n */\nfunction applyVotingRedirects(router: Router): Router {\n  router.beforeEach((to, from, next) => {\n    if (\n      to.name === 'vebal-voting' &&\n      Object.keys(votingRequest.value).length === 0\n    ) {\n      next({\n        name: 'vebal',\n        params: { networkSlug: 'ethereum' },\n      });\n    } else next();\n  });\n  return router;\n}\n","import LS_KEYS from '@/constants/local-storage.keys';\nimport { lsGet, lsSet } from '@/lib/utils';\nimport i18n from '@/plugins/i18n';\nexport { version } from '../../package.json';\n\nconst modalOpen = ref(false);\nconst locale = ref(lsGet(LS_KEYS.App.Locale, 'en-US'));\nconst defaultSwapDeadlineMinutes = 100;\nconst transactionDeadline = ref<number>(\n  lsGet(LS_KEYS.App.SwapDeadline, defaultSwapDeadlineMinutes)\n);\n\nfunction toggleModal() {\n  modalOpen.value = !modalOpen.value;\n}\n\nfunction setLocale(newLocale: string) {\n  locale.value = newLocale;\n  lsSet(LS_KEYS.App.Locale, newLocale);\n  i18n.global.locale.value = newLocale;\n}\n\nfunction setTransactionDeadline(newTransactionDeadline: number) {\n  transactionDeadline.value = newTransactionDeadline;\n  lsSet(LS_KEYS.App.SwapDeadline, newTransactionDeadline);\n}\n\nexport function useApp() {\n  return {\n    modalOpen,\n    locale,\n    transactionDeadline,\n    //methods\n    toggleModal,\n    setLocale,\n    setTransactionDeadline,\n  };\n}\n","import SafeAppsSDK from '@gnosis.pm/safe-apps-sdk';\nimport { onBeforeMount, ref } from 'vue';\n\nimport useDarkMode from '@/composables/useDarkMode';\nimport useNetwork from '@/composables/useNetwork';\nimport { tryPromiseWithTimeout } from '@/lib/utils/promise';\nimport useWeb3 from '@/services/web3/useWeb3';\nimport { hardRedirectTo } from '@/plugins/router/nav-guards';\n\nexport const isGnosisSafeApp = ref(false);\n\nasync function checkIfGnosisSafeApp(): Promise<boolean> {\n  // Can't be a Safe app if we're not running in an iframe\n  if (window.self === window.top) return false;\n\n  // Try to connect to the Gnosis UI by querying Safe info\n  // If we get no response then we're not in a Safe app\n  try {\n    await tryPromiseWithTimeout(new SafeAppsSDK().safe.getInfo(), 1000);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport default function useGnosisSafeApp() {\n  const { connectWallet, chainId } = useWeb3();\n  const { darkMode, toggleDarkMode } = useDarkMode();\n  const { networkId, getNetworkSlug } = useNetwork();\n\n  onBeforeMount(async () => {\n    // If we're running as a Safe App we want to automatically\n    // connect to the provided safe.\n    isGnosisSafeApp.value = await checkIfGnosisSafeApp();\n    if (isGnosisSafeApp.value) {\n      await connectWallet('safe');\n      if (chainId.value !== networkId.value) {\n        hardRedirectTo(`/#/${getNetworkSlug(chainId.value)}`);\n      }\n      // Disable darkmode by default\n      if (darkMode) toggleDarkMode();\n    }\n  });\n\n  return {\n    isGnosisSafeApp,\n  };\n}\n"],"names":["redirecting","ref","applyNavGuards","router","applyNetworkSubdomainRedirect","applyNetworkPathRedirects","applyPoolJoinRedirects","applyMetaData","applyVotingRedirects","hardRedirectTo","url","to","from","next","redirectUrl","getRedirectUrlFor","_a","networkSlugFromUrl","networkFromSlug","handleNetworkSlug","networkAgnosticRoutes","routerHandledRedirects","_b","_c","newPath","_d","config","Network","_e","_f","newNetwork","networkSlug","isJoinsDisabled","metaService","votingRequest","modalOpen","locale","lsGet","LS_KEYS","defaultSwapDeadlineMinutes","transactionDeadline","toggleModal","setLocale","newLocale","lsSet","i18n","setTransactionDeadline","newTransactionDeadline","useApp","isGnosisSafeApp","checkIfGnosisSafeApp","tryPromiseWithTimeout","SafeAppsSDK","useGnosisSafeApp","connectWallet","chainId","useWeb3","darkMode","toggleDarkMode","useDarkMode","networkId","getNetworkSlug","useNetwork","onBeforeMount"],"mappings":"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"}