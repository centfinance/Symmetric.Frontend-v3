{"version":3,"file":"usePoolCreation-dd4e6f0a.js","sources":["../../src/components/_global/BalRadio/BalRadio.vue","../../src/lib/utils/ethers-v6/data.ts","../../src/lib/utils/ethers-v6/index.ts","../../src/lib/utils/random.ts","../../src/services/balancer/pools/weighted-pool.service.ts","../../src/services/balancer/pools/pools.service.ts","../../src/services/balancer/balancer.service.ts","../../src/composables/pools/usePoolCreation.ts"],"sourcesContent":["<template>\n  <div class=\"inline-flex items-start\">\n    <input\n      type=\"radio\"\n      autofocus\n      :value=\"value\"\n      :checked=\"modelValue === value || checked\"\n      :name=\"name\"\n      :class=\"['bal-radio-input', inputClasses]\"\n      :disabled=\"disabled\"\n      @click=\"onChange(value)\"\n    />\n    <label\n      v-if=\"$slots.label || label\"\n      :for=\"name\"\n      :class=\"['bal-radio-label', labelClasses]\"\n      @click.prevent=\"onChange(value)\"\n    >\n      <slot name=\"label\">\n        {{ label }}\n      </slot>\n    </label>\n  </div>\n</template>\n\n<script lang=\"ts\">\nexport default defineComponent({\n  name: 'BalRadio',\n\n  props: {\n    checked: { type: Boolean, default: false },\n    name: { type: String, required: true },\n    value: { type: [String, Number], required: true },\n    modelValue: { type: [String, Number], default: '' },\n    label: { type: String, default: '' },\n    disabled: { type: Boolean, default: false },\n    size: {\n      type: String,\n      default: 'md',\n      validator: (val: string): boolean => ['sm', 'md', 'lg'].includes(val),\n    },\n    color: {\n      type: String,\n      default: 'blue',\n      validator: (val: string): boolean => ['blue'].includes(val),\n    },\n  },\n\n  emits: ['update:modelValue'],\n\n  setup(props, { emit }) {\n    function onChange(value) {\n      if (!props.disabled) emit('update:modelValue', value);\n    }\n\n    const sizeClasses = computed(() => {\n      switch (props.size) {\n        case 'sm':\n          return 'w-3 h-3';\n        case 'lg':\n          return 'w-6 h-6';\n        default:\n          return 'w-4 h-4';\n      }\n    });\n\n    const textSizeClass = computed(() => {\n      switch (props.size) {\n        case 'sm':\n          return 'leading-none text-sm';\n        case 'lg':\n          return 'leading-none text-lg';\n        default:\n          return 'leading-none text-base';\n      }\n    });\n\n    const colorClass = computed(() => {\n      if (props.disabled) return 'text-gray-500';\n      return `text-${props.color}-500`;\n    });\n\n    const cursrorClass = computed(() => {\n      if (props.disabled) return 'cursor-not-allowed';\n      return 'cursor-pointer';\n    });\n\n    const inputClasses = computed(() => {\n      return {\n        [sizeClasses.value]: true,\n        [colorClass.value]: true,\n        [cursrorClass.value]: true,\n      };\n    });\n\n    const labelClasses = computed(() => {\n      return {\n        [textSizeClass.value]: true,\n        [cursrorClass.value]: true,\n      };\n    });\n\n    return {\n      onChange,\n      inputClasses,\n      labelClasses,\n    };\n  },\n});\n</script>\n\n<style>\n.bal-radio-input {\n  @apply bg-white dark:bg-gray-900 rounded-full m-0 shadow-inner transition-all;\n  @apply border border-gray-400 dark:border-gray-500;\n\n  transition: all ease 0.25s;\n  appearance: none;\n  -webkit-print-color-adjust: exact;\n  print-color-adjust: exact;\n  display: inline-block;\n  vertical-align: middle;\n  background-origin: border-box;\n  user-select: none;\n}\n\n.bal-radio-input:focus {\n  @apply border-2 border-blue-500 dark:border-blue-400;\n}\n\n.bal-radio-input:checked {\n  background-image: url(\"data:image/svg+xml,%3csvg viewBox='0 0 16 16' fill='white' xmlns='http://www.w3.org/2000/svg'%3e%3ccircle cx='8' cy='8' r='3'/%3e%3c/svg%3e\");\n  border-color: transparent;\n  background-color: currentcolor;\n  background-size: 100% 100%;\n  background-position: center;\n  background-repeat: no-repeat;\n}\n\n.bal-radio-input:checked:focus {\n  @apply border-transparent;\n}\n\n.bal-radio-label {\n  @apply ml-2 flex-1;\n}\n</style>\n","/**\n *  A [[HexString]] whose length is even, which ensures it is a valid\n *  representation of binary data.\n */\nexport type DataHexString = string;\n\n/**\n *  A string which is prefixed with ``0x`` and followed by any number\n *  of case-agnostic hexadecimal characters.\n *\n *  It must match the regular expression ``/0x[0-9A-Fa-f]*\\/``.\n */\nexport type HexString = string;\n\n/**\n *  An object that can be used to represent binary data.\n */\nexport type BytesLike = DataHexString | Uint8Array;\n\nfunction _getBytes(\n  value: BytesLike,\n  name?: string,\n  copy?: boolean\n): Uint8Array {\n  if (value instanceof Uint8Array) {\n    if (copy) {\n      return new Uint8Array(value);\n    }\n    return value;\n  }\n\n  if (typeof value === 'string' && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {\n    const result = new Uint8Array((value.length - 2) / 2);\n    let offset = 2;\n    for (let i = 0; i < result.length; i++) {\n      result[i] = parseInt(value.substring(offset, offset + 2), 16);\n      offset += 2;\n    }\n    return result;\n  }\n  throw new Error('invalid BytesLike value');\n}\n\n/**\n *  Get a typed Uint8Array for %%value%%. If already a Uint8Array\n *  the original %%value%% is returned; if a copy is required use\n *  [[getBytesCopy]].\n *\n *  @see: getBytesCopy\n */\nexport function getBytes(value: BytesLike, name?: string): Uint8Array {\n  return _getBytes(value, name, false);\n}\n\n/**\n *  Get a typed Uint8Array for %%value%%, creating a copy if necessary\n *  to prevent any modifications of the returned value from being\n *  reflected elsewhere.\n *\n *  @see: getBytes\n */\nexport function getBytesCopy(value: BytesLike, name?: string): Uint8Array {\n  return _getBytes(value, name, true);\n}\n\n/**\n *  Returns true if %%value%% is a valid [[HexString]].\n *\n *  If %%length%% is ``true`` or a //number//, it also checks that\n *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\n *  bytes of data (e.g. ``0x1234`` is 2 bytes).\n */\nexport function isHexString(\n  value: any,\n  length?: number | boolean\n): value is `0x${string}` {\n  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n    return false;\n  }\n\n  if (typeof length === 'number' && value.length !== 2 + 2 * length) {\n    return false;\n  }\n  if (length === true && value.length % 2 !== 0) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n *  Returns true if %%value%% is a valid representation of arbitrary\n *  data (i.e. a valid [[DataHexString]] or a Uint8Array).\n */\nexport function isBytesLike(value: any): value is BytesLike {\n  return isHexString(value, true) || value instanceof Uint8Array;\n}\n\nconst HexCharacters = '0123456789abcdef';\n\n/**\n *  Returns a [[DataHexString]] representation of %%data%%.\n */\nexport function hexlify(data: BytesLike): string {\n  const bytes = getBytes(data);\n\n  let result = '0x';\n  for (let i = 0; i < bytes.length; i++) {\n    const v = bytes[i];\n    result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n  }\n  return result;\n}\n\n/**\n *  Returns a [[DataHexString]] by concatenating all values\n *  within %%data%%.\n */\nexport function concat(datas: ReadonlyArray<BytesLike>): string {\n  return '0x' + datas.map(d => hexlify(d).substring(2)).join('');\n}\n\n/**\n *  Returns the length of %%data%%, in bytes.\n */\nexport function dataLength(data: BytesLike): number {\n  if (isHexString(data, true)) {\n    return (data.length - 2) / 2;\n  }\n  return getBytes(data).length;\n}\n\nfunction zeroPad(data: BytesLike, length: number, left: boolean): string {\n  const bytes = getBytes(data);\n\n  const result = new Uint8Array(length);\n  result.fill(0);\n  if (left) {\n    result.set(bytes, length - bytes.length);\n  } else {\n    result.set(bytes, 0);\n  }\n\n  return hexlify(result);\n}\n\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **left**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **values** are in Solidity\n *  (e.g. ``uint128``).\n */\nexport function zeroPadValue(data: BytesLike, length: number): string {\n  return zeroPad(data, length, true);\n}\n\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **right**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **bytes** are in Solidity\n *  (e.g. ``bytes16``).\n */\nexport function zeroPadBytes(data: BytesLike, length: number): string {\n  return zeroPad(data, length, false);\n}\n","/**\n * This is a temporary file to be able to use new ethers-v6 utils until the complete ethers-v5 to ethers-v6 is completed.\n */\n\nimport { zeroPadBytes } from './data';\n\n/**\n *  Encodes %%text%% as a Bytes32 string.\n *\n *  This is a temporary file to be able to use new ethers-v6 utils until the complete ethers-v5 to ethers-v6 is completed.\n *  https://docs.ethers.org/v6/api/abi/#encodeBytes32String\n *  https://docs.ethers.org/v6/migrating/#migrate-utils\n */\nexport function encodeBytes32String(text: string): string {\n  // Get the bytes\n  const bytes = toUtf8Bytes(text);\n\n  // Check we have room for null-termination\n  if (bytes.length > 31) {\n    throw new Error('bytes32 string must be less than 32 bytes');\n  }\n\n  // Zero-pad (implicitly null-terminates)\n  return zeroPadBytes(bytes, 32);\n}\n\n/**\n *  The stanard normalization forms.\n */\ntype UnicodeNormalizationForm = 'NFC' | 'NFD' | 'NFKC' | 'NFKD';\n\n/**\n *  Returns the UTF-8 byte representation of %%str%%.\n *\n *  If %%form%% is specified, the string is normalized.\n */\nfunction toUtf8Bytes(str: string, form?: UnicodeNormalizationForm): Uint8Array {\n  if (form != null) {\n    str = str.normalize(form);\n  }\n\n  const result: number[] = [];\n  for (let i = 0; i < str.length; i++) {\n    const c = str.charCodeAt(i);\n\n    if (c < 0x80) {\n      result.push(c);\n    } else if (c < 0x800) {\n      result.push((c >> 6) | 0xc0);\n      result.push((c & 0x3f) | 0x80);\n    } else if ((c & 0xfc00) == 0xd800) {\n      i++;\n      const c2 = str.charCodeAt(i);\n\n      // Surrogate Pair\n      const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n      result.push((pair >> 18) | 0xf0);\n      result.push(((pair >> 12) & 0x3f) | 0x80);\n      result.push(((pair >> 6) & 0x3f) | 0x80);\n      result.push((pair & 0x3f) | 0x80);\n    } else {\n      result.push((c >> 12) | 0xe0);\n      result.push(((c >> 6) & 0x3f) | 0x80);\n      result.push((c & 0x3f) | 0x80);\n    }\n  }\n\n  return new Uint8Array(result);\n}\n","import { randomBytes } from 'crypto';\nimport { encodeBytes32String } from './ethers-v6';\n\nexport function generateSalt() {\n  return encodeBytes32String(generateRandomAsciiCharacters(31));\n}\n\n/**\n  Generates a random ASCII string with the given length\n  We only use ASCII to enforce that all the strings have 1 byte size so that the resulting string will have exactly length bytes size\n\n  Based on https://github.com/sindresorhus/crypto-random-string\n**/\nconst generateRandomAsciiCharacters = length => {\n  const asciiPrintableCharacters = [\n    ...'!\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~',\n  ];\n  // Generating entropy is faster than complex math operations, so we use the simplest way\n  const characterCount = asciiPrintableCharacters.length;\n  const maxValidSelector =\n    Math.floor(0x1_00_00 / characterCount) * characterCount - 1; // Using values above this will ruin distribution when using modular division\n  const entropyLength = 2 * Math.ceil(1.1 * length); // Generating a bit more than required so chances we need more than one pass will be really low\n  let string = '';\n  let stringLength = 0;\n\n  while (stringLength < length) {\n    // In case we had many bad values, which may happen for character sets of size above 0x8000 but close to it\n    const entropy = randomBytes(entropyLength);\n    let entropyPosition = 0;\n\n    const readUInt16LE = (uInt8Array, offset) =>\n      uInt8Array[offset] + (uInt8Array[offset + 1] << 8);\n\n    while (entropyPosition < entropyLength && stringLength < length) {\n      const entropyValue = readUInt16LE(entropy, entropyPosition);\n      entropyPosition += 2;\n      if (entropyValue > maxValidSelector) {\n        // Skip values which will ruin distribution when using modular division\n        continue;\n      }\n\n      string += asciiPrintableCharacters[entropyValue % characterCount];\n      stringLength++;\n    }\n  }\n\n  return string;\n};\n","import { toNormalizedWeights } from '@balancer-labs/sdk';\nimport {\n  Vault__factory,\n  WeightedPool__factory,\n  WeightedPoolFactory__factory,\n} from '@balancer-labs/typechain';\nimport { defaultAbiCoder } from '@ethersproject/abi';\nimport { BigNumber as EPBigNumber } from '@ethersproject/bignumber';\nimport { AddressZero } from '@ethersproject/constants';\nimport { JsonRpcProvider, TransactionResponse } from '@ethersproject/providers';\nimport { WalletProvider } from '@/dependencies/wallets/Web3Provider';\nimport BigNumber from 'bignumber.js';\nimport { formatUnits } from '@ethersproject/units';\n\nimport { PoolSeedToken } from '@/composables/pools/usePoolCreation';\nimport { isSameAddress, scale } from '@/lib/utils';\nimport { configService } from '@/services/config/config.service';\nimport { TransactionBuilder } from '@/services/web3/transactions/transaction.builder';\nimport { getOldMulticaller } from '@/dependencies/OldMulticaller';\nimport { POOLS } from '@/constants/pools';\nimport WeightedPoolFactoryV4Abi from '@/lib/abi/WeightedPoolFactoryV4.json';\nimport { generateSalt } from '@/lib/utils/random';\n\ntype Address = string;\n\nexport interface CreatePoolReturn {\n  id: string;\n  address: Address;\n}\n\nconst JOIN_KIND_INIT = 0;\n\nexport interface JoinPoolRequest {\n  assets: Address[];\n  maxAmountsIn: string[];\n  userData: any;\n  fromInternalBalance: boolean;\n}\n\nexport default class WeightedPoolService {\n  public async create(\n    provider: WalletProvider,\n    name: string,\n    symbol: string,\n    swapFee: string,\n    tokens: PoolSeedToken[],\n    owner: Address\n  ): Promise<TransactionResponse> {\n    if (!owner.length) return Promise.reject('No pool owner specified');\n\n    const tokenAddresses: Address[] = tokens.map((token: PoolSeedToken) => {\n      return token.tokenAddress;\n    });\n\n    const seedTokens = this.calculateTokenWeights(tokens);\n    const swapFeeScaled = scale(new BigNumber(swapFee), 18);\n    const rateProviders = Array(tokenAddresses.length).fill(POOLS.ZeroAddress);\n\n    const params = [\n      name,\n      symbol,\n      tokenAddresses,\n      seedTokens,\n      rateProviders,\n      swapFeeScaled.toString(),\n      owner,\n      generateSalt(),\n    ];\n\n    const txBuilder = new TransactionBuilder(provider.getSigner());\n    return await txBuilder.contract.sendTransaction({\n      contractAddress: configService.network.addresses.weightedPoolFactory,\n      abi: WeightedPoolFactoryV4Abi,\n      action: 'create',\n      params,\n    });\n  }\n\n  public async retrievePoolIdAndAddress(\n    provider: WalletProvider | JsonRpcProvider,\n    createHash: string\n  ): Promise<CreatePoolReturn | null> {\n    const receipt = await provider.getTransactionReceipt(createHash);\n    if (!receipt) return null;\n\n    const weightedPoolFactoryInterface =\n      WeightedPoolFactory__factory.createInterface();\n\n    const poolCreationEvent = receipt.logs\n      .filter(\n        log =>\n          log.address === configService.network.addresses.weightedPoolFactory\n      )\n      .map(log => {\n        try {\n          return weightedPoolFactoryInterface.parseLog(log);\n        } catch {\n          return null;\n        }\n      })\n      .find(parsedLog => parsedLog?.name === 'PoolCreated');\n\n    if (!poolCreationEvent) return null;\n    const poolAddress = poolCreationEvent.args.pool;\n\n    const pool = WeightedPool__factory.connect(poolAddress, provider);\n    const poolId = await pool.getPoolId();\n\n    return {\n      id: poolId,\n      address: poolAddress,\n    };\n  }\n\n  public async retrievePoolDetails(\n    provider: WalletProvider | JsonRpcProvider,\n    hash: string\n  ) {\n    if (!hash) return;\n    const poolDetails = await this.retrievePoolIdAndAddress(provider, hash);\n    if (poolDetails === null) return;\n\n    const poolAddress = poolDetails.address;\n    const vaultAddress = configService.network.addresses.vault;\n\n    const Multicaller = getOldMulticaller();\n    const multicaller = new Multicaller(configService.network.key, provider, [\n      ...WeightedPool__factory.abi,\n      ...Vault__factory.abi,\n    ]);\n\n    multicaller.call('name', poolAddress, 'name');\n    multicaller.call('symbol', poolAddress, 'symbol');\n    multicaller.call('owner', poolAddress, 'getOwner');\n    multicaller.call('weights', poolAddress, 'getNormalizedWeights');\n    multicaller.call('tokenInfo', vaultAddress, 'getPoolTokens', [\n      poolDetails.id,\n    ]);\n\n    const multicall = await multicaller.execute();\n\n    const details = {\n      weights: multicall.weights.map(weight => formatUnits(weight, 18)),\n      name: multicall.name,\n      owner: multicall.owner,\n      symbol: multicall.symbol,\n      tokens: multicall.tokenInfo.tokens,\n    };\n    return details;\n  }\n\n  public async initJoin(\n    provider: WalletProvider,\n    poolId: string,\n    sender: Address,\n    receiver: Address,\n    tokenAddresses: Address[],\n    initialBalancesString: string[]\n  ): Promise<TransactionResponse> {\n    const initUserData = defaultAbiCoder.encode(\n      ['uint256', 'uint256[]'],\n      [JOIN_KIND_INIT, initialBalancesString]\n    );\n\n    const value = this.value(initialBalancesString, tokenAddresses);\n\n    tokenAddresses = this.parseTokensIn(tokenAddresses);\n\n    const joinPoolRequest: JoinPoolRequest = {\n      assets: tokenAddresses,\n      maxAmountsIn: initialBalancesString,\n      userData: initUserData,\n      fromInternalBalance: false,\n    };\n\n    const vaultAddress = configService.network.addresses.vault;\n\n    const txBuilder = new TransactionBuilder(provider.getSigner());\n    return await txBuilder.contract.sendTransaction({\n      contractAddress: vaultAddress,\n      abi: Vault__factory.abi,\n      action: 'joinPool',\n      params: [poolId, sender, receiver, joinPoolRequest],\n      options: { value },\n    });\n  }\n\n  public calculateTokenWeights(tokens: PoolSeedToken[]): string[] {\n    const weights: EPBigNumber[] = tokens.map((token: PoolSeedToken) => {\n      const normalizedWeight = new BigNumber(token.weight).multipliedBy(\n        new BigNumber(1e16)\n      );\n      return EPBigNumber.from(normalizedWeight.toString());\n    });\n    const normalizedWeights = toNormalizedWeights(weights);\n    const weightStrings = normalizedWeights.map((weight: EPBigNumber) => {\n      return weight.toString();\n    });\n\n    return weightStrings;\n  }\n\n  private value(amountsIn: string[], tokensIn: string[]): EPBigNumber {\n    let value = '0';\n    const nativeAsset = configService.network.nativeAsset;\n\n    amountsIn.forEach((amount, i) => {\n      if (tokensIn[i] === nativeAsset.address) {\n        value = amount;\n      }\n    });\n\n    return EPBigNumber.from(value);\n  }\n\n  private parseTokensIn(tokensIn: string[]): string[] {\n    const nativeAsset = configService.network.nativeAsset;\n\n    return tokensIn.map(address =>\n      isSameAddress(address, nativeAsset.address) ? AddressZero : address\n    );\n  }\n}\n","import WeightedPoolService from './weighted-pool.service';\n\nexport default class PoolsService {\n  weighted: WeightedPoolService;\n\n  constructor() {\n    this.weighted = new WeightedPoolService();\n  }\n}\n\nexport const poolsService = new PoolsService();\n","import PoolsService from './pools/pools.service';\n\nexport default class BalancerService {\n  pools: PoolsService;\n\n  constructor() {\n    this.pools = new PoolsService();\n  }\n}\n\nexport const balancerService = new BalancerService();\n","import { getAddress } from '@ethersproject/address';\nimport { TransactionResponse } from '@ethersproject/providers';\nimport BigNumber from 'bignumber.js';\nimport { flatten, sumBy } from 'lodash';\nimport { computed, reactive, ref, toRefs } from 'vue';\nimport usePoolsQuery from '@/composables/queries/usePoolsQuery';\nimport useEthers from '@/composables/useEthers';\nimport useTransactions from '@/composables/useTransactions';\nimport { POOLS } from '@/constants/pools';\nimport {\n  bnum,\n  includesAddress,\n  isSameAddress,\n  lsRemove,\n  lsSet,\n  scale,\n} from '@/lib/utils';\nimport { balancerService } from '@/services/balancer/balancer.service';\nimport useWeb3 from '@/services/web3/useWeb3';\n\nimport { useTokens } from '@/providers/tokens.provider';\nimport { PoolType } from '@balancer-labs/sdk';\nimport { wNativeAssetAddress } from '../usePoolHelpers';\n\nexport const POOL_CREATION_STATE_VERSION = '1.0';\nexport const POOL_CREATION_STATE_KEY = 'poolCreationState';\n\nexport type PoolSeedToken = {\n  tokenAddress: string;\n  weight: number;\n  isLocked: boolean;\n  amount: string;\n  id: string;\n};\n\nexport type OptimisedLiquidity = {\n  liquidityRequired: string;\n  balanceRequired: string;\n};\n\ntype FeeManagementType = 'governance' | 'self';\ntype FeeType = 'fixed' | 'dynamic';\ntype FeeController = 'self' | 'other';\n\nconst emptyPoolCreationState = {\n  name: '',\n  seedTokens: [] as PoolSeedToken[],\n  activeStep: 0,\n  initialFee: '0.003',\n  isFeeGovManaged: false,\n  feeManagementType: 'governance' as FeeManagementType,\n  feeType: 'fixed' as FeeType,\n  feeController: 'self' as FeeController,\n  thirdPartyFeeController: '',\n  fee: '',\n  tokensList: [] as string[],\n  poolId: '' as string,\n  poolAddress: '',\n  symbol: '',\n  manuallySetToken: '' as string,\n  autoOptimiseBalances: false,\n  useNativeAsset: false,\n  type: PoolType.Weighted,\n  needsSeeding: false,\n  createPoolTxHash: '',\n};\n\nexport const poolCreationState = reactive({ ...emptyPoolCreationState });\nconst tokenColors = ref<string[]>([]);\nexport const hasRestoredFromSavedState = ref<boolean | null>(null);\n\nexport default function usePoolCreation() {\n  /**\n   * COMPOSABLES\n   */\n  const {\n    balanceFor,\n    priceFor,\n    getToken,\n    nativeAsset,\n    wrappedNativeAsset,\n    balancerTokenListTokens,\n    dynamicDataLoading,\n  } = useTokens();\n  const { account, getProvider } = useWeb3();\n  const { txListener } = useEthers();\n  const { addTransaction } = useTransactions();\n\n  /**\n   * COMPUTED\n   */\n  const tokensList = computed(() =>\n    [...poolCreationState.tokensList].sort((tokenA, tokenB) => {\n      return tokenA > tokenB ? 1 : -1;\n    })\n  );\n\n  const hasUnlistedToken = computed(() =>\n    tokensList.value.some(tokenAddress => {\n      return tokenAddress && isUnlistedToken(tokenAddress);\n    })\n  );\n\n  function getOptimisedLiquidity(): Record<string, OptimisedLiquidity> {\n    // need to filter out the empty tokens just in case\n    const validTokens = tokensList.value.filter(t => t !== '');\n    const optimisedLiquidity = {};\n    if (dynamicDataLoading.value) return optimisedLiquidity;\n    // token with the lowest balance is the bottleneck\n    let bottleneckToken = validTokens[0];\n    // keeping track of the lowest amt\n    let currentMin = bnum(balanceFor(validTokens[0])).times(\n      priceFor(validTokens[0])\n    );\n\n    // find the bottleneck token\n    for (const token of validTokens) {\n      const value = bnum(balanceFor(token)).times(priceFor(token));\n      if (value.lt(currentMin)) {\n        currentMin = value;\n        bottleneckToken = token;\n      }\n    }\n    let bottleneckWeight =\n      poolCreationState.seedTokens.find(t =>\n        isSameAddress(t.tokenAddress, bottleneckToken)\n      )?.weight || 0;\n    let bottleneckPrice = priceFor(bottleneckToken || '0');\n\n    // make sure that once we recognise that we are\n    // using the nativeAsset for optimisation of liquidity\n    // that we use the appropriate weights and balances\n    // since we do not want to change the original seedTokens array\n    // as the wrapped native asset there is what will\n    // be sent to the contract for creation\n    if (\n      poolCreationState.useNativeAsset &&\n      bottleneckToken === wrappedNativeAsset.value.address\n    ) {\n      bottleneckToken = nativeAsset.address;\n      bottleneckWeight =\n        poolCreationState.seedTokens.find(t =>\n          isSameAddress(t.tokenAddress, wrappedNativeAsset.value.address)\n        )?.weight || 0;\n      bottleneckPrice = priceFor(wrappedNativeAsset.value.address);\n    }\n    if (!bottleneckToken) return optimisedLiquidity;\n\n    const bip = bnum(bottleneckPrice)\n      .times(balanceFor(bottleneckToken))\n      .div(bottleneckWeight);\n\n    return getTokensScaledByBIP(bip);\n  }\n\n  const scaledLiquidity = computed((): Record<string, OptimisedLiquidity> => {\n    const scaledLiquidity = {};\n    const manuallySetToken =\n      poolCreationState.manuallySetToken === nativeAsset.address\n        ? wrappedNativeAsset.value.address\n        : poolCreationState.manuallySetToken;\n    const modifiedToken = findSeedTokenByAddress(manuallySetToken);\n    if (!modifiedToken) return scaledLiquidity;\n\n    const bip = bnum(priceFor(modifiedToken.tokenAddress || '0'))\n      .times(modifiedToken.amount)\n      .div(modifiedToken.weight);\n\n    return getTokensScaledByBIP(bip);\n  });\n\n  const maxInitialLiquidity = computed(() => {\n    return sumBy(Object.values(getOptimisedLiquidity()), (liq: any) =>\n      Number(liq.liquidityRequired)\n    );\n  });\n\n  const totalLiquidity = computed(() => {\n    let total = bnum(0);\n    for (const token of tokensList.value) {\n      total = total.plus(bnum(priceFor(token)).times(balanceFor(token)));\n    }\n    return total;\n  });\n\n  const currentLiquidity = computed(() => {\n    let total = bnum(0);\n    for (const token of poolCreationState.seedTokens) {\n      total = total.plus(\n        bnum(token.amount).times(priceFor(token.tokenAddress))\n      );\n    }\n    return total;\n  });\n\n  const poolLiquidity = computed(() => {\n    let sum = bnum(0);\n    for (const token of poolCreationState.seedTokens) {\n      sum = sum.plus(bnum(token.amount).times(priceFor(token.tokenAddress)));\n    }\n    return sum;\n  });\n\n  const poolTypeString = computed((): string => {\n    switch (poolCreationState.type) {\n      case PoolType.Weighted:\n        return 'weighted';\n      default:\n        return '';\n    }\n  });\n\n  const tokensWithNoPrice = computed(() => {\n    const validTokens = tokensList.value.filter(t => t !== '');\n    return validTokens.filter(token => priceFor(token) === 0);\n  });\n\n  const similarPools = computed(() => {\n    return flatten(similarPoolsResponse.value?.pages.map(p => p.pools));\n  });\n\n  const existingPool = computed(() => {\n    if (!similarPools.value?.length) return null;\n\n    const similarPool = similarPools.value.find(pool => {\n      if (pool.swapFee === poolCreationState.initialFee) {\n        let weightsMatch = true;\n        for (const token of pool.tokens) {\n          const relevantToken = poolCreationState.seedTokens.find(t =>\n            isSameAddress(t.tokenAddress, token.address)\n          );\n          const similarPoolWeight = Number(token.weight).toFixed(2);\n          const seedTokenWeight = ((relevantToken?.weight || 0) / 100).toFixed(\n            2\n          );\n          if (similarPoolWeight !== seedTokenWeight) {\n            weightsMatch = false;\n          }\n        }\n        return weightsMatch;\n      }\n      return false;\n    });\n    return similarPool;\n  });\n\n  const isWrappedNativeAssetPool = computed((): boolean => {\n    return includesAddress(tokensList.value, wNativeAssetAddress());\n  });\n\n  const poolOwner = computed(() => {\n    if (poolCreationState.feeManagementType === 'governance') {\n      return POOLS.DelegateOwner;\n    } else {\n      if (poolCreationState.feeController === 'self') {\n        return account.value;\n      } else {\n        return poolCreationState.thirdPartyFeeController;\n      }\n    }\n  });\n\n  /**\n   * FUNCTIONS\n   */\n  const filterOptions = computed(() => ({\n    tokens: tokensList.value,\n    useExactTokens: true,\n  }));\n  const { data: similarPoolsResponse, isLoading: isLoadingSimilarPools } =\n    usePoolsQuery(filterOptions);\n\n  function resetPoolCreationState() {\n    for (const key of Object.keys(poolCreationState)) {\n      poolCreationState[key] = emptyPoolCreationState[key];\n    }\n    setRestoredState(false);\n    resetState();\n  }\n\n  function updateTokenWeights(weights: PoolSeedToken[]) {\n    poolCreationState.seedTokens = weights;\n  }\n\n  function sortSeedTokens() {\n    poolCreationState.seedTokens.sort((tokenA, tokenB) => {\n      return tokenA.tokenAddress.toLowerCase() >\n        tokenB.tokenAddress.toLowerCase()\n        ? 1\n        : -1;\n    });\n  }\n\n  function proceed() {\n    if (!similarPools.value.length && poolCreationState.activeStep === 1) {\n      poolCreationState.activeStep += 2;\n    } else {\n      poolCreationState.activeStep += 1;\n    }\n    saveState();\n  }\n\n  function goBack() {\n    if (!similarPools.value.length && poolCreationState.activeStep === 3) {\n      poolCreationState.activeStep -= 2;\n      return;\n    }\n    poolCreationState.activeStep -= 1;\n    if (hasRestoredFromSavedState.value) {\n      setRestoredState(false);\n    }\n  }\n\n  function findSeedTokenByAddress(address: string) {\n    return poolCreationState.seedTokens.find((token: PoolSeedToken) =>\n      isSameAddress(token.tokenAddress, address)\n    );\n  }\n\n  function setFeeManagement(type: FeeManagementType) {\n    poolCreationState.feeManagementType = type;\n  }\n\n  function setFeeType(type: FeeType) {\n    poolCreationState.feeType = type;\n  }\n\n  function setStep(step: number) {\n    poolCreationState.activeStep = step;\n  }\n\n  function setFeeController(controller: FeeController) {\n    poolCreationState.feeController = controller;\n  }\n\n  function setTrpController(address: string) {\n    poolCreationState.thirdPartyFeeController = address;\n  }\n\n  function updateTokenColors(colors: string[]) {\n    tokenColors.value = colors;\n  }\n\n  function updateManuallySetToken(address: string) {\n    poolCreationState.manuallySetToken = address;\n  }\n\n  function clearAmounts() {\n    for (const token of poolCreationState.seedTokens) {\n      token.amount = '0';\n    }\n  }\n\n  function setAmountsToMaxBalances() {\n    for (const token of poolCreationState.seedTokens) {\n      token.amount = balanceFor(token.tokenAddress);\n    }\n  }\n\n  function setTokensList(newList: string[]) {\n    poolCreationState.tokensList = newList;\n  }\n\n  function getTokensScaledByBIP(\n    bip: BigNumber\n  ): Record<string, OptimisedLiquidity> {\n    const optimisedLiquidity = {};\n    for (const token of poolCreationState.seedTokens) {\n      // get the price for a single token\n      const tokenPrice = bnum(priceFor(token.tokenAddress));\n      // the usd value needed for its weight\n      const liquidityRequired: BigNumber = bip.times(token.weight);\n      const balanceRequired: BigNumber = liquidityRequired.div(tokenPrice);\n      optimisedLiquidity[token.tokenAddress] = {\n        liquidityRequired: liquidityRequired.toString(),\n        balanceRequired: balanceRequired.toString(),\n      };\n    }\n    return optimisedLiquidity;\n  }\n\n  function getAmounts() {\n    const amounts = poolCreationState.seedTokens.map((token: PoolSeedToken) => {\n      return token.amount;\n    });\n    return amounts;\n  }\n\n  function getScaledAmounts() {\n    const scaledAmounts: string[] = poolCreationState.seedTokens.map(\n      (token: PoolSeedToken) => {\n        const tokenInfo = getToken(token.tokenAddress);\n        if (!tokenInfo) return '0';\n        const amount = new BigNumber(token.amount);\n        const scaledAmount = scale(amount, tokenInfo.decimals);\n        const scaledRoundedAmount = scaledAmount.toFixed(\n          0,\n          BigNumber.ROUND_FLOOR\n        );\n        return scaledRoundedAmount;\n      }\n    );\n    return scaledAmounts;\n  }\n\n  function getPoolSymbol() {\n    let valid = true;\n\n    const tokenSymbols = poolCreationState.seedTokens.map(\n      (token: PoolSeedToken) => {\n        const weightRounded = Math.round(token.weight);\n        const tokenInfo = getToken(token.tokenAddress);\n        if (!tokenInfo) {\n          valid = false;\n        }\n        return tokenInfo\n          ? `${Math.round(weightRounded)}${tokenInfo.symbol}`\n          : '';\n      }\n    );\n\n    return valid ? tokenSymbols.join('-') : '';\n  }\n\n  async function createPool(): Promise<TransactionResponse> {\n    if (hasUnlistedToken.value) {\n      throw new Error('Invalid pool creation due to unlisted tokens.');\n    }\n    const provider = getProvider();\n\n    const tx = await balancerService.pools.weighted.create(\n      provider,\n      poolCreationState.name,\n      poolCreationState.symbol,\n      poolCreationState.initialFee,\n      poolCreationState.seedTokens,\n      poolOwner.value\n    );\n    poolCreationState.createPoolTxHash = tx.hash;\n    saveState();\n\n    addTransaction({\n      id: tx.hash,\n      type: 'tx',\n      action: 'createPool',\n      summary: poolCreationState.name,\n      details: {\n        name: poolCreationState.name,\n      },\n    });\n\n    txListener(tx, {\n      onTxConfirmed: async () => {\n        retrievePoolAddress(tx.hash);\n      },\n      onTxFailed: () => {\n        console.log('Create failed');\n      },\n    });\n\n    return tx;\n  }\n\n  async function joinPool() {\n    const provider = getProvider();\n\n    const tokenAddresses: string[] = poolCreationState.seedTokens.map(\n      (token: PoolSeedToken) => {\n        if (\n          isSameAddress(token.tokenAddress, wrappedNativeAsset.value.address) &&\n          poolCreationState.useNativeAsset\n        ) {\n          return nativeAsset.address;\n        }\n        return token.tokenAddress;\n      }\n    );\n    const tx = await balancerService.pools.weighted.initJoin(\n      provider,\n      poolCreationState.poolId,\n      account.value,\n      account.value,\n      tokenAddresses,\n      getScaledAmounts()\n    );\n\n    addTransaction({\n      id: tx.hash,\n      type: 'tx',\n      action: 'fundPool',\n      summary: poolCreationState.name,\n    });\n\n    txListener(tx, {\n      onTxConfirmed: async () => {\n        resetState();\n      },\n      onTxFailed: () => {\n        console.log('Seed failed');\n      },\n    });\n\n    return tx;\n  }\n\n  function setActiveStep(step: number) {\n    poolCreationState.activeStep = step;\n  }\n\n  function saveState() {\n    lsSet(\n      POOL_CREATION_STATE_KEY,\n      JSON.stringify(poolCreationState),\n      POOL_CREATION_STATE_VERSION\n    );\n  }\n\n  function resetState() {\n    lsRemove(POOL_CREATION_STATE_KEY);\n  }\n\n  function importState(state) {\n    for (const key of Object.keys(poolCreationState)) {\n      if (key === 'activeStep') continue;\n      if (key === 'seedTokens') {\n        const seedTokens = state['seedTokens'].filter(token => !!token.address);\n        poolCreationState['seedTokens'] = seedTokens;\n        continue;\n      }\n      poolCreationState[key] = state[key];\n    }\n  }\n\n  function setRestoredState(value: boolean) {\n    hasRestoredFromSavedState.value = value;\n  }\n\n  async function retrievePoolAddress(hash: string) {\n    const response =\n      await balancerService.pools.weighted.retrievePoolIdAndAddress(\n        getProvider(),\n        hash\n      );\n    if (response !== null) {\n      poolCreationState.poolId = response.id;\n      poolCreationState.poolAddress = response.address;\n      poolCreationState.needsSeeding = true;\n      saveState();\n    }\n  }\n\n  // when restoring from a pool creation transaction (not from localstorage)\n  async function retrievePoolDetails(hash: string) {\n    const details = await balancerService.pools.weighted.retrievePoolDetails(\n      getProvider(),\n      hash\n    );\n    if (!details) return;\n    poolCreationState.seedTokens = details.tokens\n      .map((token, i) => {\n        return {\n          tokenAddress: getAddress(token),\n          weight: Number(details.weights[i]) * 100,\n          isLocked: true,\n          amount: '0',\n          id: i.toString(),\n        };\n      })\n      .filter(token => {\n        return !!token.tokenAddress;\n      });\n    poolCreationState.tokensList = details.tokens;\n    poolCreationState.createPoolTxHash = hash;\n    poolCreationState.activeStep = 3;\n    hasRestoredFromSavedState.value = true;\n\n    await retrievePoolAddress(hash);\n  }\n\n  function isUnlistedToken(tokenAddress: string) {\n    return tokenAddress !== '' && !balancerTokenListTokens.value[tokenAddress];\n  }\n\n  return {\n    ...toRefs(poolCreationState),\n    updateTokenWeights,\n    proceed,\n    setFeeManagement,\n    setFeeType,\n    setFeeController,\n    setTrpController,\n    setStep,\n    resetPoolCreationState,\n    updateTokenColors,\n    goBack,\n    getPoolSymbol,\n    getAmounts,\n    getScaledAmounts,\n    createPool,\n    joinPool,\n    setActiveStep,\n    updateManuallySetToken,\n    sortSeedTokens,\n    clearAmounts,\n    setAmountsToMaxBalances,\n    saveState,\n    resetState,\n    importState,\n    setRestoredState,\n    setTokensList,\n    retrievePoolAddress,\n    retrievePoolDetails,\n    getOptimisedLiquidity,\n    currentLiquidity,\n    scaledLiquidity,\n    tokensWithNoPrice,\n    similarPools,\n    isLoadingSimilarPools,\n    existingPool,\n    totalLiquidity,\n    maxInitialLiquidity,\n    poolLiquidity,\n    poolTypeString,\n    tokenColors,\n    isWrappedNativeAssetPool,\n    hasUnlistedToken,\n    hasRestoredFromSavedState,\n    isUnlistedToken,\n  };\n}\n"],"names":["_sfc_main","defineComponent","val","props","emit","onChange","value","sizeClasses","computed","textSizeClass","colorClass","cursrorClass","inputClasses","labelClasses","_createElementVNode","_ctx","_normalizeClass","_cache","$event","_hoisted_2","_openBlock","_createElementBlock","_getBytes","name","copy","result","offset","i","getBytes","HexCharacters","hexlify","data","bytes","v","zeroPad","length","left","zeroPadBytes","encodeBytes32String","text","toUtf8Bytes","str","form","c","c2","pair","generateSalt","generateRandomAsciiCharacters","asciiPrintableCharacters","characterCount","maxValidSelector","entropyLength","string","stringLength","entropy","randomBytes","entropyPosition","readUInt16LE","uInt8Array","entropyValue","JOIN_KIND_INIT","WeightedPoolService","provider","symbol","swapFee","tokens","owner","tokenAddresses","token","seedTokens","swapFeeScaled","scale","BigNumber","rateProviders","POOLS","params","TransactionBuilder","configService","WeightedPoolFactoryV4Abi","createHash","receipt","weightedPoolFactoryInterface","WeightedPoolFactory__factory","poolCreationEvent","log","parsedLog","poolAddress","WeightedPool__factory","hash","poolDetails","vaultAddress","Multicaller","getOldMulticaller","multicaller","Vault__factory","multicall","formatUnits","weight","poolId","sender","receiver","initialBalancesString","initUserData","defaultAbiCoder","joinPoolRequest","weights","normalizedWeight","EPBigNumber","toNormalizedWeights","amountsIn","tokensIn","nativeAsset","amount","isSameAddress","address","AddressZero","PoolsService","__publicField","BalancerService","balancerService","POOL_CREATION_STATE_VERSION","POOL_CREATION_STATE_KEY","emptyPoolCreationState","PoolType","poolCreationState","reactive","tokenColors","ref","hasRestoredFromSavedState","usePoolCreation","balanceFor","priceFor","getToken","wrappedNativeAsset","balancerTokenListTokens","dynamicDataLoading","useTokens","account","getProvider","useWeb3","txListener","useEthers","addTransaction","useTransactions","tokensList","tokenA","tokenB","hasUnlistedToken","tokenAddress","isUnlistedToken","getOptimisedLiquidity","validTokens","t","optimisedLiquidity","bottleneckToken","currentMin","bnum","bottleneckWeight","_a","bottleneckPrice","_b","bip","getTokensScaledByBIP","scaledLiquidity","manuallySetToken","modifiedToken","findSeedTokenByAddress","maxInitialLiquidity","sumBy","liq","totalLiquidity","total","currentLiquidity","poolLiquidity","sum","poolTypeString","tokensWithNoPrice","similarPools","flatten","similarPoolsResponse","p","existingPool","pool","weightsMatch","relevantToken","similarPoolWeight","seedTokenWeight","isWrappedNativeAssetPool","includesAddress","wNativeAssetAddress","poolOwner","filterOptions","isLoadingSimilarPools","usePoolsQuery","resetPoolCreationState","key","setRestoredState","resetState","updateTokenWeights","sortSeedTokens","proceed","saveState","goBack","setFeeManagement","type","setFeeType","setStep","step","setFeeController","controller","setTrpController","updateTokenColors","colors","updateManuallySetToken","clearAmounts","setAmountsToMaxBalances","setTokensList","newList","tokenPrice","liquidityRequired","balanceRequired","getAmounts","getScaledAmounts","tokenInfo","getPoolSymbol","valid","tokenSymbols","weightRounded","createPool","tx","retrievePoolAddress","joinPool","setActiveStep","lsSet","lsRemove","importState","state","response","retrievePoolDetails","details","getAddress","toRefs"],"mappings":"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"}