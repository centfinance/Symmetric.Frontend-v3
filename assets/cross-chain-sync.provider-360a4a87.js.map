{"version":3,"file":"cross-chain-sync.provider-360a4a87.js","sources":["../../src/providers/cross-chain-sync.provider.ts"],"sourcesContent":["import { Network } from '@/lib/config/types';\n\nimport { useCrossChainNetwork } from '@/composables/queries/useCrossChainNetwork';\nimport {\n  OmniEscrowLock,\n  useOmniEscrowLocksQuery,\n} from '@/composables/queries/useOmniEscrowLocksQuery';\nimport symbolKeys from '@/constants/symbol.keys';\nimport { OmniVotingEscrow } from '@/services/balancer/contracts/contracts/omni-voting-escrow';\nimport { configService } from '@/services/config/config.service';\nimport useWeb3 from '@/services/web3/useWeb3';\nimport { safeInject } from './inject';\nimport configs from '@/lib/config';\nimport { GaugeWorkingBalanceHelper } from '@/services/balancer/contracts/contracts/gauge-working-balance-helper';\nimport { useI18n } from 'vue-i18n';\nimport { getMessagesBySrcTxHash } from '@layerzerolabs/scan-client';\nimport { isPoolBoostsEnabled } from '@/composables/useNetwork';\n\nexport enum NetworkSyncState {\n  Unsynced = 'Unsynced',\n  Syncing = 'Syncing',\n  Synced = 'Synced',\n  Unknown = 'Unknown',\n}\nexport interface NetworksBySyncState {\n  synced: Network[];\n  unsynced: Network[];\n  syncing: Network[];\n}\n\nexport type L2VeBalBalances = Record<number, string> | null;\n\nexport interface TempSyncingNetworks {\n  networks: Network[];\n  syncTimestamp?: number;\n}\n\nexport interface SyncTxHashes {\n  [key: string]: string;\n}\n\n// all networks that are supported by cross-chain sync feature\nexport const veBalSyncSupportedNetworks = Object.keys(configs)\n  .filter(key => configs[Number(key)].supportsVeBalSync)\n  .map(key => Number(key));\n\nconst REFETCH_INTERVAL = 1000 * 30; // 30 seconds\nconst REFETCH_GET_LAYER_ZERO_TX_LINKS_INTERVAL = 1000 * 5;\n\nexport const crossChainSyncProvider = () => {\n  const { account, getSigner } = useWeb3();\n  const { t } = useI18n();\n\n  const syncingNetworksFromStorage = localStorage.getItem(\n    'tempSyncingNetworks'\n  );\n\n  // as subgraph is lagging behind onchain data, we need to fake synced networks\n  const tempSyncingNetworks = ref<Record<string, TempSyncingNetworks>>(\n    syncingNetworksFromStorage ? JSON.parse(syncingNetworksFromStorage) : {}\n  );\n\n  const syncTxHashesFromStorage = localStorage.getItem('syncTxHashes');\n\n  const syncTxHashes = ref<Record<string, SyncTxHashes>>(\n    syncTxHashesFromStorage ? JSON.parse(syncTxHashesFromStorage) : {}\n  );\n\n  const syncLayerZeroTxLinks = ref<Record<string, string>>({});\n\n  /**\n   * omniVotingEscrowLocks contains the user's veBAL data that is known by the bridge contract\n   * it is used to determine sync status to l2 networks\n   * slope and bias is how a user's \"balance\" is stored on the smart contract\n   */\n  const {\n    data: omniEscrowResponse,\n    isInitialLoading: isLoadingOmniEscrow,\n    refetch: refetchOmniEscrow,\n    isError: isOmniEscrowError,\n  } = useOmniEscrowLocksQuery(account);\n\n  // if omniEscrowLocks is empty, then all networks are unsynced\n  const allNetworksUnsynced = computed(\n    () => omniEscrowResponse.value?.omniVotingEscrowLocks.length === 0\n  );\n\n  const omniEscrowLocksMap = computed(() => {\n    if (allNetworksUnsynced.value || !omniEscrowResponse.value) return null;\n\n    return omniEscrowResponse.value.omniVotingEscrowLocks.reduce(\n      (acc: Record<number, OmniEscrowLock>, item) => {\n        acc[item.dstChainId] = item;\n        return acc;\n      },\n      {}\n    );\n  });\n\n  const mainnetCrossChainNetwork = useCrossChainNetwork(\n    Network.MAINNET,\n    omniEscrowLocksMap\n  );\n\n  const mainnetEscrowLocks = computed(\n    () => mainnetCrossChainNetwork.votingEscrowLocks.value\n  );\n\n  type UseCrossChainNetworkResponse = Record<\n    Network,\n    ReturnType<typeof useCrossChainNetwork>\n  >;\n  const crossChainNetworks: UseCrossChainNetworkResponse =\n    {} as UseCrossChainNetworkResponse;\n\n  veBalSyncSupportedNetworks.forEach(networkId => {\n    crossChainNetworks[networkId] = useCrossChainNetwork(\n      networkId,\n      omniEscrowLocksMap\n    );\n  });\n\n  const isLoading = computed(() => {\n    return (\n      isLoadingOmniEscrow.value || mainnetCrossChainNetwork.isLoading.value\n    );\n  });\n\n  const networksSyncState = computed(() => {\n    const result = veBalSyncSupportedNetworks.reduce((acc, network) => {\n      acc[network] = crossChainNetworks[network].getNetworkSyncState(\n        omniEscrowLocksMap.value?.[configs[network].layerZeroChainId || ''],\n        mainnetEscrowLocks.value\n      );\n      return acc;\n    }, {});\n    return result;\n  });\n\n  // Returns networks lists by sync state\n  const networksBySyncState = computed<NetworksBySyncState>(() => {\n    if (!networksSyncState.value) {\n      return {\n        synced: [],\n        unsynced: [],\n        syncing: [],\n      };\n    }\n\n    const networksWithValidSyncState = Object.keys(networksSyncState.value).map(\n      v => Number(v)\n    );\n\n    return {\n      synced: networksWithValidSyncState.filter(\n        network => networksSyncState.value[network] === NetworkSyncState.Synced\n      ) as Network[],\n      unsynced: networksWithValidSyncState.filter(\n        network =>\n          networksSyncState.value[network] === NetworkSyncState.Unsynced\n      ),\n      syncing: networksWithValidSyncState.filter(\n        network =>\n          networksSyncState.value[network] === NetworkSyncState.Syncing ||\n          tempSyncingNetworks.value[account.value]?.networks.includes(network)\n      ),\n    };\n  });\n\n  // List of networks to show in unsynced networks card\n  const showingUnsyncedNetworks = computed(() => {\n    const commonArr = [\n      ...networksBySyncState.value.unsynced,\n      ...networksBySyncState.value.syncing,\n    ];\n    return [...new Set(commonArr)];\n  });\n\n  const hasError = computed(() => {\n    const hasVotingEscrowError = veBalSyncSupportedNetworks.some(network => {\n      return crossChainNetworks[network].isError.value;\n    });\n    return isOmniEscrowError.value || hasVotingEscrowError;\n  });\n\n  const l2VeBalBalances = computed<L2VeBalBalances>(() => {\n    const result = veBalSyncSupportedNetworks.reduce((acc, network) => {\n      acc[network] = crossChainNetworks[network].calculateVeBAlBalance();\n      return acc;\n    }, {});\n    return result;\n  });\n\n  const warningMessage = computed(() => {\n    if (networksBySyncState.value.syncing.length > 0) {\n      return {\n        title: t('crossChainBoost.syncProcessWarning.title'),\n        text: t('crossChainBoost.syncProcessWarning.description'),\n      };\n    }\n\n    return null;\n  });\n\n  const infoMessage = computed(() => {\n    if (warningMessage.value) {\n      return null;\n    }\n\n    if (networksBySyncState.value.synced.length > 0) {\n      return {\n        title: t('crossChainBoost.updateGauge.title'),\n        text: t('crossChainBoost.updateGauge.description'),\n      };\n    }\n\n    return null;\n  });\n\n  async function sync(network: Network) {\n    const contractAddress = configService.network.addresses.omniVotingEscrow;\n    if (!contractAddress) throw new Error('No contract address found');\n    const signer = getSigner();\n    const omniVotingEscrowContract = new OmniVotingEscrow(contractAddress);\n\n    const layerZeroChainId = configs[network].layerZeroChainId;\n\n    if (!layerZeroChainId) {\n      throw new Error('Must specify layer zero chain id');\n    }\n\n    const tx = await omniVotingEscrowContract.estimateSendUserBalance(\n      signer,\n      layerZeroChainId\n    );\n\n    const { nativeFee } = tx;\n\n    const sendUserBalanceTx = await omniVotingEscrowContract.sendUserBalance({\n      signer,\n      userAddress: account.value,\n      chainId: layerZeroChainId,\n      nativeFee,\n    });\n\n    return sendUserBalanceTx;\n  }\n\n  async function refetch() {\n    await Promise.all([\n      refetchOmniEscrow(),\n      mainnetCrossChainNetwork.refetch(),\n    ]);\n    if (omniEscrowLocksMap.value) {\n      const promises = networksBySyncState.value.syncing.map(networkId => {\n        return crossChainNetworks[networkId].refetch();\n      });\n      await Promise.all(promises);\n    }\n  }\n\n  let disposeRefetchOnInterval: NodeJS.Timeout;\n  function refetchOnInterval() {\n    disposeRefetchOnInterval = setInterval(() => {\n      void refetch();\n    }, REFETCH_INTERVAL);\n  }\n\n  function setTempSyncingNetworks(syncingNetworks: Network[]) {\n    if (!tempSyncingNetworks.value?.[account.value]) {\n      tempSyncingNetworks.value[account.value] = {\n        networks: syncingNetworks,\n        syncTimestamp: Date.now(),\n      };\n    } else {\n      tempSyncingNetworks.value[account.value].networks = [\n        ...tempSyncingNetworks.value[account.value].networks,\n        ...syncingNetworks,\n      ];\n    }\n\n    tempSyncingNetworks.value[account.value].syncTimestamp = Date.now();\n\n    return tempSyncingNetworks.value;\n  }\n\n  async function setSyncTxHashes(network: Network, txHash: string) {\n    syncTxHashes.value[account.value] = {\n      ...syncTxHashes.value[account.value],\n      [network]: txHash,\n    };\n\n    localStorage.setItem('syncTxHashes', JSON.stringify(syncTxHashes.value));\n  }\n\n  function clearTempSyncingNetworksFromSynced() {\n    if (!tempSyncingNetworks.value[account.value]) return;\n\n    tempSyncingNetworks.value[account.value].networks =\n      tempSyncingNetworks.value[account.value].networks.filter(network => {\n        return !networksBySyncState.value.synced.includes(network);\n      });\n\n    localStorage.setItem(\n      'tempSyncingNetworks',\n      JSON.stringify(tempSyncingNetworks.value)\n    );\n  }\n\n  async function getGaugeWorkingBalance(gaugeAddress: string) {\n    if (!isPoolBoostsEnabled.value) return;\n\n    const contractAddress =\n      configService.network.addresses.gaugeWorkingBalanceHelper;\n    if (!contractAddress) throw new Error('No contract address found');\n\n    const signer = getSigner();\n    const workingBalanceHelperContract = new GaugeWorkingBalanceHelper(\n      contractAddress\n    );\n\n    return workingBalanceHelperContract.getWorkingBalanceToSupplyRatios({\n      signer,\n      userAddress: account.value,\n      gauge: gaugeAddress,\n    });\n  }\n\n  async function shouldPokeGauge(gaugeAddress: string) {\n    const balance = await getGaugeWorkingBalance(gaugeAddress);\n\n    /*\n     *  balance[0] is ratio of the current `working_balance` of the user to the current `working_supply` of the gauge\n     *  balance[1] is ratio of the projected `working_balance` of the user (after `user_checkpoint`), to the projected `working_supply` of the gauge\n     *\n     *  so if balance[1] > balance[0] then the user should poke the gauge\n     */\n    return balance && balance[1]?.gt(balance[0]);\n  }\n\n  async function getLayerZeroTxLink(txHash: string) {\n    const { messages } = await getMessagesBySrcTxHash(101, txHash);\n    const message = messages[0];\n\n    if (!message) {\n      console.error('No message found in Layer Zero');\n      return '';\n    }\n\n    const { srcUaAddress, dstUaAddress, dstChainId, srcUaNonce } = message;\n    const link = `https://layerzeroscan.com/101/address/${srcUaAddress}/message/${dstChainId}/address/${dstUaAddress}/nonce/${srcUaNonce}`;\n\n    return link;\n  }\n\n  watch(\n    () => networksBySyncState.value,\n    newVal => {\n      if (newVal.synced.length > 0) {\n        const hasSyncingMismatch = newVal.syncing.some(network => {\n          return newVal.synced.includes(network);\n        });\n\n        if (hasSyncingMismatch) {\n          clearTempSyncingNetworksFromSynced();\n        }\n      }\n\n      if (newVal.syncing.length > 0 && !disposeRefetchOnInterval) {\n        refetchOnInterval();\n      }\n      if (newVal.syncing.length === 0 && disposeRefetchOnInterval) {\n        clearInterval(disposeRefetchOnInterval);\n      }\n    }\n  );\n\n  let disposeRefetchLayerZeroTxLink: NodeJS.Timeout;\n  function getLayerZeroTxLinkOnInterval(networks: string[]) {\n    if (disposeRefetchLayerZeroTxLink) {\n      clearInterval(disposeRefetchLayerZeroTxLink);\n    }\n    let retryCount = 0;\n    disposeRefetchLayerZeroTxLink = setInterval(async () => {\n      for (const network of networks) {\n        const hash = syncTxHashes.value[account.value][network];\n        syncLayerZeroTxLinks.value[network] = await getLayerZeroTxLink(hash);\n      }\n\n      retryCount++;\n\n      if (\n        networks.every(network => syncLayerZeroTxLinks.value[network]) ||\n        retryCount > 10\n      ) {\n        clearInterval(disposeRefetchLayerZeroTxLink);\n      }\n    }, REFETCH_GET_LAYER_ZERO_TX_LINKS_INTERVAL);\n  }\n\n  watch(\n    () => [syncTxHashes.value, account.value],\n    async values => {\n      const val = values[0];\n      if (!val || !val[account.value]) return;\n\n      getLayerZeroTxLinkOnInterval(Object.keys(val[account.value]));\n    },\n    { immediate: true, deep: true }\n  );\n\n  return {\n    showingUnsyncedNetworks,\n    hasError,\n    omniEscrowLocksMap,\n    networksSyncState,\n    isLoading,\n    networksBySyncState,\n    l2VeBalBalances,\n    sync,\n    refetch,\n    tempSyncingNetworks,\n    refetchOnInterval,\n    setTempSyncingNetworks,\n    warningMessage,\n    infoMessage,\n    getGaugeWorkingBalance,\n    getLayerZeroTxLink,\n    syncTxHashes,\n    setSyncTxHashes,\n    syncLayerZeroTxLinks,\n    shouldPokeGauge,\n  };\n};\n\nexport type CrossChainSyncResponse = ReturnType<typeof crossChainSyncProvider>;\nexport const CrossChainSyncProviderSymbol: InjectionKey<CrossChainSyncResponse> =\n  Symbol(symbolKeys.Providers.CrossChainSync);\n\nexport function provideCrossChainSync() {\n  const crossChainSyncResponse = crossChainSyncProvider();\n  provide(CrossChainSyncProviderSymbol, crossChainSyncResponse);\n  return crossChainSyncResponse;\n}\n\nexport const useCrossChainSync = (): CrossChainSyncResponse => {\n  return safeInject(CrossChainSyncProviderSymbol);\n};\n"],"names":["NetworkSyncState","NetworkSyncState2","veBalSyncSupportedNetworks","configs","key","CrossChainSyncProviderSymbol","symbolKeys","useCrossChainSync","safeInject"],"mappings":"kIAkBO,IAAAA,GAAAC,IACLA,EAAA,SAAA,WACAA,EAAA,QAAA,UACAA,EAAA,OAAA,SACAA,EAAA,QAAA,UAJUA,IAAAD,GAAA,CAAA,CAAA,EAwBL,MAAAE,EAAA,OAAA,KAAAC,CAAA,EAAA,OAAAC,GAAAD,EAAA,OAAAC,CAAA,CAAA,EAAA,iBAAA,EAAA,IAAAA,GAAA,OAAAA,CAAA,CAAA,EA0YAC,EAAA,OAAAC,EAAA,UAAA,cAAA,EASAC,EAAA,IACLC,EAAAH,CAAA"}