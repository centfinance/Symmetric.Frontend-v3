{"version":3,"file":"useRelayerApproval-b64164b6.js","sources":["../../src/constants/vue-query.ts","../../src/composables/queries/useRelayerApprovalQuery.ts","../../src/composables/approvals/useRelayerApprovalTx.ts","../../src/dependencies/Relayer.ts","../../src/composables/approvals/useRelayerApproval.ts"],"sourcesContent":["import { twentyFourHoursInMs } from '@/composables/useTime';\n\nexport const FETCH_ONCE_OPTIONS = {\n  refetchOnMount: false,\n  refetchOnWindowFocus: false,\n  refetchOnReconnect: false,\n  staleTime: twentyFourHoursInMs,\n};\n","import { Vault__factory } from '@balancer-labs/typechain';\nimport { getEthersContract } from '@/dependencies/EthersContract';\nimport { computed, reactive, Ref } from 'vue';\nimport { useQuery, UseQueryOptions } from '@tanstack/vue-query';\n\nimport QUERY_KEYS from '@/constants/queryKeys';\nimport { FETCH_ONCE_OPTIONS } from '@/constants/vue-query';\nimport { configService } from '@/services/config/config.service';\nimport { rpcProviderService } from '@/services/rpc-provider/rpc-provider.service';\nimport useWeb3 from '@/services/web3/useWeb3';\n\nimport useNetwork from '../useNetwork';\n\n/**\n * TYPES\n */\ntype QueryResponse = boolean;\ntype QueryOptions = UseQueryOptions<QueryResponse>;\n\nexport default function useRelayerApprovalQuery(\n  relayer: Ref<string>,\n  options: QueryOptions = {}\n) {\n  /**\n   * COMPOSABLES\n   */\n  const { account, isWalletReady } = useWeb3();\n  const { networkId } = useNetwork();\n\n  /**\n   * COMPUTED\n   */\n  const enabled = computed(() => isWalletReady.value);\n\n  const EthersContract = getEthersContract();\n  const vaultContract = computed(\n    () =>\n      new EthersContract(\n        configService.network.addresses.vault,\n        Vault__factory.abi,\n        rpcProviderService.jsonProvider\n      )\n  );\n\n  /**\n   * QUERY INPUTS\n   */\n  const queryKey = reactive(\n    QUERY_KEYS.Account.RelayerApprovals(networkId, account, relayer)\n  );\n\n  const queryFn = async (): Promise<boolean> => {\n    if (!relayer.value) {\n      return true;\n    }\n\n    const approved = await vaultContract.value.hasApprovedRelayer(\n      account.value,\n      relayer.value\n    );\n\n    return approved;\n  };\n\n  const queryOptions = reactive({\n    enabled,\n    ...FETCH_ONCE_OPTIONS,\n    ...options,\n  });\n\n  return useQuery<QueryResponse>(\n    queryKey,\n    queryFn,\n    queryOptions as QueryOptions\n  );\n}\n","import { Vault__factory } from '@balancer-labs/typechain';\nimport { TransactionResponse } from '@ethersproject/abstract-provider';\nimport { computed, Ref, ref } from 'vue';\nimport { useI18n } from 'vue-i18n';\n\nimport { configService } from '@/services/config/config.service';\nimport useWeb3 from '@/services/web3/useWeb3';\nimport { TransactionActionInfo } from '@/types/transactions';\n\nimport useRelayerApprovalQuery from '../queries/useRelayerApprovalQuery';\nimport useEthers from '../useEthers';\nimport useTransactions from '../useTransactions';\nimport { TransactionBuilder } from '@/services/web3/transactions/transaction.builder';\nimport { relayerAddressMap, RelayerType } from './useRelayerApproval';\n\nconst vaultAddress = configService.network.addresses.vault;\n\nexport default function useRelayerApprovalTx(\n  relayer: RelayerType,\n  isEnabled: Ref<boolean> = ref(true)\n) {\n  /**\n   * STATE\n   */\n  const init = ref(false);\n  const approving = ref(false);\n  const approved = ref(false);\n\n  /**\n   * COMPOSABLES\n   */\n  const { getSigner, account } = useWeb3();\n  const relayerAddress = ref(relayerAddressMap[relayer]);\n  const { txListener } = useEthers();\n  const { addTransaction } = useTransactions();\n  const { t } = useI18n();\n  const relayerApproval = useRelayerApprovalQuery(relayerAddress);\n\n  /**\n   * COMPUTED\n   */\n  const isUnlocked = computed(\n    () =>\n      approved.value || (isEnabled.value ? !!relayerApproval.data.value : true)\n  );\n\n  const loading = computed(\n    (): boolean =>\n      relayerApproval.isLoading.value || relayerApproval.isError.value\n  );\n\n  const action = computed(\n    (): TransactionActionInfo => ({\n      label: t('transactionSummary.approveRelayer', [relayer]),\n      loadingLabel: t('actionSteps.approve.loadingLabel'),\n      confirmingLabel: t('confirming'),\n      stepTooltip: t('approveRelayerTooltip'),\n      action: approve,\n    })\n  );\n\n  /**\n   * METHODS\n   */\n  async function approve(): Promise<TransactionResponse> {\n    try {\n      init.value = true;\n\n      const txBuilder = new TransactionBuilder(getSigner());\n      const tx = await txBuilder.contract.sendTransaction({\n        contractAddress: configService.network.addresses.vault,\n        abi: Vault__factory.abi,\n        action: 'setRelayerApproval',\n        params: [account.value, relayerAddress.value, true],\n      });\n\n      init.value = false;\n      approving.value = true;\n\n      handleTransaction(tx);\n      return tx;\n    } catch (e) {\n      console.log(e);\n      init.value = false;\n      approving.value = false;\n      return Promise.reject(e);\n    }\n  }\n\n  async function handleTransaction(tx): Promise<void> {\n    addTransaction({\n      id: tx.hash,\n      type: 'tx',\n      action: 'approve',\n      summary: t('transactionSummary.approveRelayer', [relayer]),\n      details: {\n        contractAddress: vaultAddress,\n        spender: relayerAddress.value,\n      },\n    });\n\n    approved.value = await txListener(tx, {\n      onTxConfirmed: async () => {\n        approving.value = false;\n        relayerApproval.refetch();\n      },\n      onTxFailed: () => {\n        approving.value = false;\n      },\n    });\n  }\n\n  return {\n    action,\n    init,\n    approve,\n    approving,\n    approved,\n    isUnlocked,\n    loading,\n  };\n}\n","import { Relayer } from '@balancer-labs/sdk';\nimport { handleDependencyError } from '.';\n\nlet _Relayer: typeof Relayer = Relayer;\n\n/**\n * Uses the real Relayer instance by default but allows injecting Relayer mocks from tests\n */\nexport function initRelayer(RelayerInstance: typeof Relayer = Relayer) {\n  _Relayer = RelayerInstance;\n}\n\nexport function getRelayer() {\n  if (!_Relayer) {\n    handleDependencyError('Relayer');\n  }\n  return _Relayer;\n}\n","import useWeb3 from '@/services/web3/useWeb3';\nimport { computed, ref, watch } from 'vue';\nimport useNetwork from '../useNetwork';\nimport { Vault } from '@balancer-labs/sdk';\nimport { configService } from '@/services/config/config.service';\nimport { Vault__factory } from '@balancer-labs/typechain';\nimport { useI18n } from 'vue-i18n';\nimport { TransactionActionInfo } from '@/types/transactions';\nimport useRelayerApprovalTx from '@/composables/approvals/useRelayerApprovalTx';\nimport useGnosisSafeApp from '@/composables/useGnosisSafeApp';\nimport { COW_RELAYER_CONTRACT_ADDRESS } from '@/services/cowswap/constants';\nimport { isWalletConnectWallet } from '@/services/web3/wallet-names';\nimport { useUserSettings } from '@/providers/user-settings.provider';\nimport { getRelayer } from '@/dependencies/Relayer';\n\n/**\n * TYPES\n */\nexport enum RelayerType {\n  COWSWAP = 'Cowswap',\n  LIDO = 'Lido',\n  BATCH = 'Batch',\n}\n\nexport const relayerAddressMap = {\n  [RelayerType.COWSWAP]: COW_RELAYER_CONTRACT_ADDRESS,\n  [RelayerType.LIDO]: configService.network.addresses.lidoRelayer,\n  [RelayerType.BATCH]: configService.network.addresses.batchRelayer,\n};\n\n/**\n * STATE\n */\nconst relayerSignature = ref<string>('');\n\nexport default function useRelayerApproval(relayerType: RelayerType) {\n  /**\n   * COMPOSABLES\n   */\n  const { account, getSigner, connector } = useWeb3();\n  const { networkId } = useNetwork();\n  const { t } = useI18n();\n  const { isGnosisSafeApp } = useGnosisSafeApp();\n  const relayerApprovalTx = useRelayerApprovalTx(relayerType);\n  const { supportSignatures } = useUserSettings();\n\n  const signatureAction: TransactionActionInfo = {\n    label: t('signRelayerApproval'),\n    loadingLabel: t('checkWallet'),\n    confirmingLabel: t('signingRelayerApproval'),\n    stepTooltip: t('signRelayerApprovalTooltip'),\n    action: signRelayerApproval as () => Promise<any>,\n    isSignAction: true,\n  };\n\n  /**\n   * COMPUTED\n   */\n\n  const relayerApprovalAction = computed((): TransactionActionInfo => {\n    return !supportSignatures.value ||\n      isGnosisSafeApp.value ||\n      isWalletConnectWallet(connector.value?.id)\n      ? relayerApprovalTx.action.value\n      : signatureAction;\n  });\n\n  /**\n   * METHODS\n   */\n  async function signRelayerApproval(): Promise<void> {\n    const Relayer = getRelayer();\n    const relayerAddress = relayerAddressMap[relayerType];\n    const signer = getSigner();\n    const signerAddress = await signer.getAddress();\n    const signature = await Relayer.signRelayerApproval(\n      relayerAddress,\n      signerAddress,\n      signer,\n      Vault__factory.connect(\n        configService.network.addresses.vault,\n        signer\n      ) as unknown as Vault\n    );\n    relayerSignature.value = signature;\n  }\n\n  /**\n   * WATCHERS\n   */\n  watch([account, networkId], () => {\n    relayerSignature.value = '';\n  });\n\n  return {\n    relayerSignature,\n    relayerApprovalAction,\n    relayerApprovalTx,\n  };\n}\n"],"names":["FETCH_ONCE_OPTIONS","twentyFourHoursInMs","useRelayerApprovalQuery","relayer","options","account","isWalletReady","useWeb3","networkId","useNetwork","enabled","computed","EthersContract","getEthersContract","vaultContract","configService","Vault__factory","rpcProviderService","queryKey","reactive","QUERY_KEYS","queryFn","queryOptions","useQuery","vaultAddress","useRelayerApprovalTx","isEnabled","ref","init","approving","approved","getSigner","relayerAddress","relayerAddressMap","txListener","useEthers","addTransaction","useTransactions","t","useI18n","relayerApproval","isUnlocked","loading","action","approve","tx","TransactionBuilder","handleTransaction","e","_Relayer","Relayer","getRelayer","handleDependencyError","RelayerType","COW_RELAYER_CONTRACT_ADDRESS","relayerSignature","useRelayerApproval","relayerType","connector","isGnosisSafeApp","useGnosisSafeApp","relayerApprovalTx","supportSignatures","useUserSettings","signatureAction","signRelayerApproval","relayerApprovalAction","isWalletConnectWallet","_a","signer","signerAddress","signature","watch"],"mappings":"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"}