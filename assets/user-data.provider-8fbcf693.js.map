{"version":3,"file":"user-data.provider-8fbcf693.js","sources":["../../src/lib/utils/exceptions.ts","../../src/composables/queries/useStakedSharesQuery.ts","../../src/services/balancer/contracts/contracts/vebal-proxy.ts","../../src/services/staking/staking-rewards.service.ts","../../src/composables/queries/useUserBoostsQuery.ts","../../src/lib/utils/subgraph.ts","../../src/composables/queries/useUserGaugeSharesQuery.ts","../../src/composables/queries/useUserPoolSharesQuery.ts","../../src/providers/user-data.provider.ts"],"sourcesContent":["export function logFetchException(failedFetchMessage: string, error: unknown) {\n  console.trace(failedFetchMessage, {\n    cause: error,\n  });\n}\n","import { Ref } from 'vue';\nimport { useQuery, UseQueryOptions } from '@tanstack/vue-query';\n\nimport QUERY_KEYS from '@/constants/queryKeys';\nimport useWeb3 from '@/services/web3/useWeb3';\nimport { GaugeShare } from './useUserGaugeSharesQuery';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport { bnSum } from '@/lib/utils';\nimport { formatUnits } from '@ethersproject/units';\nimport { logFetchException } from '@/lib/utils/exceptions';\nimport { getMulticaller } from '@/dependencies/Multicaller';\n\n/**\n * TYPES\n */\ntype QueryResponse = {\n  [poolId: string]: string;\n};\ntype QueryOptions = UseQueryOptions<QueryResponse>;\n\n/**\n * Fetches staked shares for all user positions using onchain calls.\n *\n * We have to do this via the contract because the subgraph is too slow.\n * We want users to receive instant feedback that their staked balances are updated.\n */\nexport default function useStakedSharesQuery(\n  userGaugeShares: Ref<GaugeShare[] | undefined>,\n  options: QueryOptions = {}\n) {\n  /**\n   * COMPOSABLES\n   */\n  const { account, isWalletReady } = useWeb3();\n\n  /**\n   * QUERY KEY\n   */\n  const queryKey = reactive(\n    QUERY_KEYS.User.Pool.StakedShares(userGaugeShares, account)\n  );\n\n  /**\n   * COMPUTED\n   */\n  const enabled = computed(\n    (): boolean => !!userGaugeShares.value && isWalletReady.value\n  );\n\n  /**\n   * QUERY FUNCTION\n   */\n  const queryFn = async () => {\n    try {\n      if (!userGaugeShares.value) return {};\n\n      let result = {} as Record<string, Record<string, BigNumber>>;\n      const Multicaller = getMulticaller();\n      const multicaller = new Multicaller();\n\n      userGaugeShares.value.forEach(gaugeShare => {\n        multicaller.call({\n          key: `${gaugeShare.gauge.poolId}.${gaugeShare.gauge.id}`,\n          address: gaugeShare.gauge.id,\n          function: 'balanceOf',\n          abi: ['function balanceOf(address) returns (uint256)'],\n          params: [account.value],\n        });\n      });\n\n      result = await multicaller.execute();\n      const shareMap = {} as Record<string, string>;\n\n      for (const poolId in result) {\n        const gauges = result[poolId];\n        const gaugeShares = Object.values(gauges).map(shares =>\n          formatUnits(shares)\n        );\n        const shareSum = bnSum(gaugeShares).toString();\n        shareMap[poolId] = shareSum;\n      }\n\n      return shareMap;\n    } catch (error) {\n      logFetchException('Failed to fetch staked share balance', error);\n      throw Error;\n    }\n  };\n\n  /**\n   * QUERY OPTIONS\n   */\n  const queryOptions = reactive({\n    enabled,\n    refetchOnWindowFocus: false,\n    ...options,\n  });\n\n  return useQuery<QueryResponse>(\n    queryKey,\n    queryFn,\n    queryOptions as QueryOptions\n  );\n}\n","import {\n  EthersContract,\n  getEthersContract,\n} from '@/dependencies/EthersContract';\nimport { getAddress } from '@ethersproject/address';\nimport { formatUnits } from '@ethersproject/units';\nimport { mapValues } from 'lodash';\n\nimport veBalProxyABI from '@/lib/abi/veDelegationProxy.json';\nimport { configService } from '@/services/config/config.service';\nimport { rpcProviderService } from '@/services/rpc-provider/rpc-provider.service';\nimport { walletService as walletServiceInstance } from '@/services/web3/wallet.service';\nimport { getOldMulticaller } from '@/dependencies/OldMulticaller';\nimport veBalProxyABIL2 from '@/lib/abi/veDelegationProxyL2.json';\nimport { networkId } from '@/composables/useNetwork';\nimport { Network } from '@/lib/config/types';\n\nexport class VeBALProxy {\n  instance: EthersContract;\n\n  constructor(\n    public readonly address: string,\n    private readonly provider = rpcProviderService.jsonProvider,\n    private readonly abi = networkId.value === Network.MAINNET\n      ? veBalProxyABI\n      : veBalProxyABIL2,\n    private readonly config = configService,\n    private readonly walletService = walletServiceInstance\n  ) {\n    const Contract = getEthersContract();\n    this.instance = new Contract(this.address, this.abi, this.provider);\n  }\n\n  async getAdjustedBalance(address: string) {\n    const balance = await this.instance.adjustedBalanceOf(getAddress(address));\n    return formatUnits(balance, 18);\n  }\n\n  async getVeBalTotalSupplyL2() {\n    const totalSupply = await this.instance.totalSupply();\n    return formatUnits(totalSupply, 18);\n  }\n\n  async getAdjustedBalances(addresses: string) {\n    const multicaller = this.getMulticaller();\n    for (const address of addresses) {\n      multicaller.call(address, this.address, 'adjustedBalanceOf', [\n        getAddress(address),\n      ]);\n    }\n\n    const response = await multicaller.execute();\n    return mapValues(response, balance => formatUnits(balance || '0', 18));\n  }\n\n  private getMulticaller() {\n    const Multicaller = getOldMulticaller();\n    return new Multicaller(this.config.network.key, this.provider, this.abi);\n  }\n}\n","import { getAddress } from '@ethersproject/address';\nimport { formatUnits } from '@ethersproject/units';\nimport { mapValues } from 'lodash';\n\nimport { bnum } from '@/lib/utils';\nimport { configService } from '@/services/config/config.service';\nimport BalancerContractsService from '../balancer/contracts/balancer-contracts.service';\nimport { LiquidityGauge } from '../balancer/contracts/contracts/liquidity-gauge';\nimport { VeBALProxy } from '../balancer/contracts/contracts/vebal-proxy';\nimport { GaugeShare } from '@/composables/queries/useUserGaugeSharesQuery';\nimport { UserBoosts } from '@/composables/queries/useUserBoostsQuery';\nimport { networkId } from '@/composables/useNetwork';\nimport { Network } from '@/lib/config/types';\n\nexport class StakingRewardsService {\n  async getWorkingSupplyForGauges(gaugeAddresses: string[]) {\n    // start with a fresh multicaller\n    const multicaller = LiquidityGauge.getMulticaller();\n\n    for (const gaugeAddress of gaugeAddresses) {\n      multicaller.call(\n        getAddress(gaugeAddress),\n        getAddress(gaugeAddress),\n        'working_supply'\n      );\n    }\n    const result = await multicaller.execute();\n    const supplies = mapValues(result, weight => formatUnits(weight, 18));\n    return supplies;\n  }\n\n  /**\n   * getBoostDeps\n   *\n   * Fetches data required to calculate boosts\n   * 1. vebal total supply.\n   * 2. Given user's vebal balance.\n   *\n   * @param {string} userAddress - Account to fetch data for.\n   * @param {string[]} gaugeAddresses - Gauge's to fetch data for.\n   * @returns Set of data described in description above.\n   */\n  async getBoostDeps(userAddress: string) {\n    const veBalProxy = new VeBALProxy(\n      configService.network.addresses.veDelegationProxy\n    );\n\n    let veBALTotalSupply = '0';\n    if (networkId.value === Network.MAINNET) {\n      const lockInfo = await new BalancerContractsService().veBAL.getLockInfo(\n        userAddress\n      );\n      veBALTotalSupply = lockInfo.totalSupply;\n    } else {\n      // get l2 veBAL total supply from delegation proxy\n      veBALTotalSupply = await veBalProxy.getVeBalTotalSupplyL2();\n    }\n\n    // need to use veBAL balance from the proxy as the balance from the proxy takes\n    // into account the amount of delegated veBAL as well\n    const userVeBALBalance = await veBalProxy.getAdjustedBalance(userAddress);\n\n    return {\n      veBALTotalSupply,\n      userVeBALBalance,\n    };\n  }\n\n  /**\n   * calcUserBoost\n   *\n   * Pure function for calculating a user's boost for a given gauge.\n   * See: https://www.notion.so/veBAL-Boost-7a2ae8b6c8ff470f9dbe5b6bab4ff989#3037cbd3f619457681d63627db92541a\n   *\n   * @param {string} userGaugeBalance - User's balance in gauge.\n   * @param {string} gaugeTotalSupply - The gauge's total supply.\n   * @param {string} userVeBALBalance - User's veBAL balance.\n   * @param {string} veBALTotalSupply - veBAL total supply.\n   * @returns User's boost value for given gauge.\n   */\n  calcUserBoost({\n    userGaugeBalance,\n    gaugeTotalSupply,\n    userVeBALBalance,\n    veBALTotalSupply,\n  }: {\n    userGaugeBalance: string;\n    gaugeTotalSupply: string;\n    userVeBALBalance: string;\n    veBALTotalSupply: string;\n  }): string {\n    const _userGaugeBalance = bnum(userGaugeBalance);\n    const _gaugeTotalSupply = bnum(gaugeTotalSupply);\n    const _userVeBALBalance = bnum(userVeBALBalance);\n    const _veBALTotalSupply = bnum(veBALTotalSupply);\n    const boost = bnum(1).plus(\n      bnum(1.5)\n        .times(_userVeBALBalance)\n        .div(_veBALTotalSupply)\n        .times(_gaugeTotalSupply)\n        .div(_userGaugeBalance)\n    );\n    const minBoost = bnum(2.5).lt(boost) ? 2.5 : boost;\n\n    return minBoost.toString();\n  }\n\n  /**\n   * getUserBoosts\n   *\n   * Fetches user boost values for given set of gauges. Returns map of poolId ->\n   * boost.\n   *\n   * @param {string} userAddress - Account to fetch boosts for.\n   * @param {GaugeShare[]} gaugeShares - Gauges to calculate boosts for.\n   * @returns Map of poolId -> boost\n   */\n  async getUserBoosts({\n    userAddress,\n    gaugeShares,\n  }: {\n    userAddress: string;\n    gaugeShares: GaugeShare[];\n  }): Promise<UserBoosts> {\n    const { veBALTotalSupply, userVeBALBalance } = await this.getBoostDeps(\n      userAddress\n    );\n\n    const boosts = gaugeShares.map(gaugeShare => {\n      const boost = this.calcUserBoost({\n        userGaugeBalance: gaugeShare.balance,\n        gaugeTotalSupply: gaugeShare.gauge.totalSupply,\n        userVeBALBalance,\n        veBALTotalSupply,\n      });\n\n      return [gaugeShare.gauge.poolId, boost];\n    });\n\n    return Object.fromEntries(boosts);\n  }\n}\n\nexport const stakingRewardsService = new StakingRewardsService();\n","import { logFetchException } from '@/lib/utils/exceptions';\nimport { computed, reactive, Ref } from 'vue';\nimport { useQuery, UseQueryOptions } from '@tanstack/vue-query';\n\nimport QUERY_KEYS from '@/constants/queryKeys';\nimport useWeb3 from '@/services/web3/useWeb3';\nimport { stakingRewardsService } from '@/services/staking/staking-rewards.service';\nimport { GaugeShare } from './useUserGaugeSharesQuery';\nimport { isPoolBoostsEnabled } from '../useNetwork';\n\n/**\n * TYPES\n */\nexport type UserBoosts = {\n  [poolId: string]: string;\n};\ntype QueryOptions = UseQueryOptions<UserBoosts>;\n\n/**\n * useUserBoostsQuery\n *\n * Fetches a pool > boost map for the current account using a given gauge shares\n * array. The gauge shares could be all the user's staked positions or for an\n * individual pool.\n *\n * @param {Ref<GaugeShare>} gaugeShares - The gauges to fetch boost values for.\n * @param {QueryOptions} options - useQuery options.\n * @returns Pool ID to boost value map.\n */\nexport default function useUserBoostsQuery(\n  gaugeShares: Ref<undefined> | Ref<GaugeShare[]>,\n  options: QueryOptions = {}\n) {\n  /**\n   * COMPOSABLES\n   */\n  const { account, isWalletReady } = useWeb3();\n\n  /**\n   * QUERY KEY\n   */\n  const queryKey = reactive(QUERY_KEYS.User.Boosts(account, gaugeShares));\n\n  /**\n   * COMPUTED\n   */\n  const enabled = computed(\n    (): boolean => !!gaugeShares.value && isWalletReady.value\n  );\n\n  /**\n   * QUERY FUNCTION\n   */\n  const queryFn = async () => {\n    try {\n      // If we don't have user's gaugeShares we can't calculate boosts\n      if (!gaugeShares.value || gaugeShares.value.length === 0) return {};\n      // We don't have boosts on L2s. Adding this to the enabled conditional\n      // causes permanent loading states, so instead just return empty.\n      if (!isPoolBoostsEnabled.value) return {};\n\n      return await stakingRewardsService.getUserBoosts({\n        userAddress: account.value,\n        gaugeShares: gaugeShares.value,\n      });\n    } catch (error) {\n      logFetchException('Failed to fetch user boost values', error);\n      throw error;\n    }\n  };\n\n  /**\n   * QUERY OPTIONS\n   */\n  const queryOptions = reactive({\n    enabled,\n    refetchOnWindowFocus: false,\n    ...options,\n  });\n\n  return useQuery<UserBoosts>(queryKey, queryFn, queryOptions as QueryOptions);\n}\n","import { jsonToGraphQLQuery } from 'json-to-graphql-query';\n\nexport async function subgraphRequest<T = any>({\n  url,\n  query,\n  options = {},\n}: {\n  url: string;\n  query: any;\n  options?: any;\n}): Promise<T> {\n  const res = await fetch(url, {\n    method: 'POST',\n    headers: {\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n      ...options?.headers,\n    },\n    body: JSON.stringify({ query: jsonToGraphQLQuery({ query }) }),\n  });\n  const { data }: { data: T } = await res.json();\n  return data;\n}\n","import { computed, reactive, Ref } from 'vue';\nimport { useQuery, UseQueryOptions } from '@tanstack/vue-query';\n\nimport QUERY_KEYS from '@/constants/queryKeys';\nimport { subgraphRequest } from '@/lib/utils/subgraph';\nimport { configService } from '@/services/config/config.service';\nimport useWeb3 from '@/services/web3/useWeb3';\n\n/**\n * TYPES\n */\nexport type GaugeShare = {\n  balance: string;\n  gauge: {\n    id: string;\n    poolAddress: string;\n    poolId: string;\n    totalSupply: string;\n    isPreferentialGauge: boolean;\n    isKilled: boolean;\n  };\n};\n\nexport type UserGaugeShares = {\n  __name: 'GaugeShares';\n  gaugeShares: GaugeShare[];\n};\ntype QueryOptions = UseQueryOptions<GaugeShare[]>;\n\n/**\n * useUserGaugeSharesQuery\n *\n * Fetches all gaugeShares for the current user or for a specific pool if\n * poolAddress is provided.\n *\n * @param {Ref<string>} poolAddress - Pool to fetch gaugeShares for.\n * @param {QueryOptions} options - useQuery options.\n * @returns {GaugeShare[]} An array of user gauge shares.\n */\nexport default function useUserGaugeSharesQuery(\n  poolAddress?: Ref<string>,\n  options: QueryOptions = {}\n) {\n  /**\n   * COMPOSABLES\n   */\n  const { account, isWalletReady } = useWeb3();\n\n  /**\n   * QUERY KEY\n   */\n  const queryKey = reactive(QUERY_KEYS.User.Gauges(account, poolAddress));\n\n  /**\n   * COMPUTED\n   */\n  const enabled = computed(\n    (): boolean =>\n      !!configService.network.subgraphs.gauge && isWalletReady.value\n  );\n\n  const queryArgs = computed(() => {\n    if (poolAddress?.value)\n      return {\n        where: {\n          user: account.value.toLowerCase(),\n          balance_gt: '0',\n          gauge_: { pool: poolAddress.value.toLowerCase() },\n        },\n      };\n\n    return { where: { user: account.value.toLowerCase(), balance_gt: '0' } };\n  });\n\n  const subgraphQuery = computed(() => ({\n    __name: 'GaugeShares',\n    gaugeShares: {\n      __args: queryArgs.value,\n      balance: true,\n      gauge: {\n        id: true,\n        poolAddress: true,\n        poolId: true,\n        totalSupply: true,\n        isPreferentialGauge: true,\n        isKilled: true,\n      },\n    },\n  }));\n\n  /**\n   * QUERY FUNCTION\n   */\n  const queryFn = async () => {\n    try {\n      const { gaugeShares } = await subgraphRequest<UserGaugeShares>({\n        url: configService.network.subgraphs.gauge,\n        query: subgraphQuery.value,\n      });\n\n      return gaugeShares;\n    } catch (error) {\n      console.error('Failed to fetch pool gauges user', {\n        cause: error,\n      });\n      throw error;\n    }\n  };\n\n  /**\n   * QUERY OPTIONS\n   */\n  const queryOptions = reactive({\n    enabled,\n    refetchOnWindowFocus: false,\n    ...options,\n  });\n\n  return useQuery<GaugeShare[]>(\n    queryKey,\n    queryFn,\n    queryOptions as QueryOptions\n  );\n}\n","import { useQuery, UseQueryOptions } from '@tanstack/vue-query';\n\nimport QUERY_KEYS from '@/constants/queryKeys';\nimport useWeb3 from '@/services/web3/useWeb3';\nimport { balancerSubgraphService } from '@/services/balancer/subgraph/balancer-subgraph.service';\n\n/**\n * TYPES\n */\ntype PoolShareMap = {\n  [poolId: string]: string;\n};\ntype QueryOptions = UseQueryOptions<PoolShareMap>;\n\n/**\n * useUserPoolSharesQuery\n *\n * Fetches all poolShares for the current user.\n *\n * @param {UseQueryOptions} options - useQuery options.\n * @returns {PoolShareMap} A map of poolID -> bpt balance.\n */\nexport default function useUserPoolSharesQuery(options: QueryOptions = {}) {\n  /**\n   * COMPOSABLES\n   */\n  const { account, isWalletReady } = useWeb3();\n\n  /**\n   * QUERY KEY\n   */\n  const queryKey = reactive(QUERY_KEYS.User.Pools(account));\n\n  /**\n   * COMPUTED\n   */\n  const enabled = computed((): boolean => isWalletReady.value);\n\n  /**\n   * QUERY FUNCTION\n   */\n  const queryFn = async () => {\n    try {\n      const poolShares = await balancerSubgraphService.poolShares.get({\n        where: {\n          userAddress: account.value.toLowerCase(),\n        },\n      });\n\n      // Create a map from poolShares using poolId as key and balance as value.\n      return poolShares.reduce(\n        (acc, poolShare) => ({\n          ...acc,\n          [poolShare.poolId.id]: poolShare.balance,\n        }),\n        {}\n      );\n    } catch (error) {\n      console.error('Failed users pool shares', {\n        cause: error,\n      });\n      throw error;\n    }\n  };\n\n  /**\n   * QUERY OPTIONS\n   */\n  const queryOptions = reactive({\n    enabled,\n    refetchOnWindowFocus: false,\n    ...options,\n  });\n\n  return useQuery<PoolShareMap>(\n    queryKey,\n    queryFn,\n    queryOptions as QueryOptions\n  );\n}\n","/**\n * Provides user data on wallet connection or change.\n *\n * Fetch any user data that needs to be generally accessible here.\n */\nimport useStakedSharesQuery from '@/composables/queries/useStakedSharesQuery';\nimport useUserBoostsQuery from '@/composables/queries/useUserBoostsQuery';\nimport useUserGaugeSharesQuery from '@/composables/queries/useUserGaugeSharesQuery';\nimport useUserPoolSharesQuery from '@/composables/queries/useUserPoolSharesQuery';\nimport useVeBalLockInfoQuery from '@/composables/queries/useVeBalLockInfoQuery';\nimport symbolKeys from '@/constants/symbol.keys';\nimport { InjectionKey, provide } from 'vue';\nimport { safeInject } from './inject';\n\nexport const userDataProvider = () => {\n  /**\n   * COMPOSABLES\n   */\n  // Fetch all user's pool shares.\n  const userPoolSharesQuery = useUserPoolSharesQuery();\n\n  // Fetches all user's gaugeShares.\n  const userGaugeSharesQuery = useUserGaugeSharesQuery();\n  const { data: userGaugeShares } = userGaugeSharesQuery;\n\n  // Fetch all user's staked share balances via onchain multicall.\n  const stakedSharesQuery = useStakedSharesQuery(userGaugeShares);\n\n  // Fetches map of boost values for user's staked shares.\n  const userBoostsQuery = useUserBoostsQuery(userGaugeShares);\n\n  const lockQuery = useVeBalLockInfoQuery();\n\n  return {\n    userPoolSharesQuery,\n    userGaugeSharesQuery,\n    stakedSharesQuery,\n    userBoostsQuery,\n    lockQuery,\n  };\n};\n\n/**\n * Provide setup: response type + symbol.\n */\nexport type UserDataResponse = ReturnType<typeof userDataProvider>;\nexport const UserDataProviderSymbol: InjectionKey<UserDataResponse> = Symbol(\n  symbolKeys.Providers.UserData\n);\n\nexport function provideUserData() {\n  provide(UserDataProviderSymbol, userDataProvider());\n}\n\nexport function useUserData(): UserDataResponse {\n  return safeInject(UserDataProviderSymbol);\n}\n"],"names":["logFetchException","failedFetchMessage","error","useStakedSharesQuery","userGaugeShares","options","account","isWalletReady","useWeb3","queryKey","reactive","QUERY_KEYS","enabled","computed","queryFn","result","Multicaller","getMulticaller","multicaller","gaugeShare","shareMap","poolId","gauges","gaugeShares","shares","formatUnits","shareSum","bnSum","queryOptions","useQuery","VeBALProxy","address","provider","rpcProviderService","abi","networkId","Network","veBalProxyABI","veBalProxyABIL2","config","configService","walletService","walletServiceInstance","__publicField","Contract","getEthersContract","balance","getAddress","totalSupply","addresses","response","mapValues","getOldMulticaller","StakingRewardsService","gaugeAddresses","LiquidityGauge","gaugeAddress","weight","userAddress","veBalProxy","veBALTotalSupply","BalancerContractsService","userVeBALBalance","userGaugeBalance","gaugeTotalSupply","_userGaugeBalance","bnum","_gaugeTotalSupply","_userVeBALBalance","_veBALTotalSupply","boost","boosts","stakingRewardsService","useUserBoostsQuery","isPoolBoostsEnabled","subgraphRequest","url","query","res","jsonToGraphQLQuery","data","useUserGaugeSharesQuery","poolAddress","queryArgs","subgraphQuery","useUserPoolSharesQuery","balancerSubgraphService","acc","poolShare","userDataProvider","userPoolSharesQuery","userGaugeSharesQuery","stakedSharesQuery","userBoostsQuery","lockQuery","useVeBalLockInfoQuery","UserDataProviderSymbol","symbolKeys","provideUserData","provide","useUserData","safeInject"],"mappings":"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"}