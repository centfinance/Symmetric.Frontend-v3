{"version":3,"file":"useVeBalLockInfoQuery-e92ea085.js","sources":["../../src/services/balancer/contracts/contracts/protocol-fees-collector.ts","../../src/services/balancer/contracts/contracts/vault.ts","../../src/services/balancer/contracts/contracts/veBAL.ts","../../src/services/balancer/contracts/balancer-contracts.service.ts","../../src/composables/queries/useVeBalLockInfoQuery.ts"],"sourcesContent":["import { formatUnits } from '@ethersproject/units';\nimport { Contract } from 'ethers';\n\nimport ProtocolFeesCollectorAbi from '@/lib/abi/ProtocolFeesCollector.json';\n\nimport Vault from './vault';\n\n/**\n * @summary Interface to the vaults protocol fees collector contract.\n * @description Requires vault instance since this is where the\n * protocol fees collector address is set.\n * @arg vault instantiated Vault class\n */\nexport default class ProtocolFeesCollector {\n  address?: string;\n  instance?: Contract;\n\n  constructor(private readonly vault: Vault) {}\n\n  /**\n   * @summary Fetches protocol fee collector contract address.\n   * @returns contract address\n   */\n  public async getAddress(): Promise<string> {\n    return (await this.vault.instance.getProtocolFeesCollector()) as string;\n  }\n\n  /**\n   * @summary Instantiates a contract instance for the protocol fees collector.\n   * @returns Ethers Contract instance\n   */\n  public async getInstance(): Promise<Contract> {\n    this.address = await this.getAddress();\n    return new Contract(\n      this.address,\n      ProtocolFeesCollectorAbi,\n      this.vault.service.provider\n    );\n  }\n\n  /**\n   * @summary Fetches protcol fee percentage.\n   * @description If onchain call fails, returns 0 so there are no catastrophic failures\n   * @returns percentage as fractional number, e.g. 0.1 = 10%\n   */\n  public async getSwapFeePercentage(): Promise<number> {\n    try {\n      this.instance = await this.getInstance();\n      const scaledPercentage = await this.instance.getSwapFeePercentage();\n      return Number(formatUnits(scaledPercentage, 18));\n    } catch (error) {\n      console.error('Failed to fetch protocol fee', error);\n      return 0;\n    }\n  }\n}\n","import { PoolType, toNormalizedWeights } from '@balancer-labs/sdk';\nimport { Vault__factory } from '@balancer-labs/typechain';\nimport { getAddress } from '@ethersproject/address';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport { formatUnits } from '@ethersproject/units';\nimport { Contract } from 'ethers';\nimport { pick } from 'lodash';\n\nimport {\n  isStableLike,\n  isSwappingHaltable,\n  isWeightedLike,\n  isDeep,\n  isComposableStableLike,\n  isComposableStable,\n} from '@/composables/usePoolHelpers';\nimport VaultAbi from '@/lib/abi/VaultAbi.json';\nimport { isSameAddress } from '@/lib/utils';\nimport { Pool } from '@/services/pool/types';\nimport {\n  LinearPoolDataMap,\n  OnchainPoolData,\n  OnchainTokenDataMap,\n  RawLinearPoolData,\n  RawLinearPoolDataMap,\n  RawOnchainPoolData,\n  RawPoolTokens,\n} from '@/services/pool/types';\nimport { TokenInfoMap } from '@/types/TokenList';\n\nimport Service from '../balancer-contracts.service';\nimport ProtocolFeesCollector from './protocol-fees-collector';\nimport { getOldMulticaller } from '@/dependencies/OldMulticaller';\n\nexport default class Vault {\n  service: Service;\n  instance: Contract;\n\n  constructor(service: Service, instanceABI = VaultAbi) {\n    this.service = service;\n    this.instance = new Contract(\n      this.service.config.addresses.vault,\n      instanceABI,\n      this.service.provider\n    );\n  }\n\n  public get protocolFeesCollector(): ProtocolFeesCollector {\n    return new ProtocolFeesCollector(this);\n  }\n\n  public async getPoolData(\n    pool: Pool,\n    id: string,\n    type: PoolType,\n    tokens: TokenInfoMap\n  ): Promise<OnchainPoolData> {\n    const poolAddress = getAddress(id.slice(0, 42));\n    let result = <RawOnchainPoolData>{};\n\n    const Multicaller = getOldMulticaller();\n    const vaultMultiCaller = new Multicaller(\n      this.service.config.key,\n      this.service.provider,\n      Vault__factory.abi\n    );\n\n    const poolMulticaller = new Multicaller(\n      this.service.config.key,\n      this.service.provider,\n      this.service.allPoolABIs\n    );\n\n    poolMulticaller.call('totalSupply', poolAddress, 'totalSupply');\n    poolMulticaller.call('decimals', poolAddress, 'decimals');\n    poolMulticaller.call('swapFee', poolAddress, 'getSwapFeePercentage');\n\n    if (isWeightedLike(type)) {\n      poolMulticaller.call('weights', poolAddress, 'getNormalizedWeights', []);\n\n      if (isSwappingHaltable(type)) {\n        poolMulticaller.call('swapEnabled', poolAddress, 'getSwapEnabled');\n      }\n    } else if (isStableLike(type)) {\n      poolMulticaller.call('amp', poolAddress, 'getAmplificationParameter');\n\n      if (isComposableStableLike(type)) {\n        // Overwrite totalSupply with virtualSupply for StablePhantom pools\n        poolMulticaller.call('totalSupply', poolAddress, 'getVirtualSupply');\n        if (isComposableStable(type)) {\n          // Overwrite totalSupply with actualSupply for ComposableStable pools\n          poolMulticaller.call('totalSupply', poolAddress, 'getActualSupply');\n        }\n      }\n\n      if (isDeep(pool)) {\n        Object.keys(tokens).forEach((token, i) => {\n          poolMulticaller.call(`linearPools.${token}.id`, token, 'getPoolId');\n          poolMulticaller.call(\n            `linearPools.${token}.priceRate`,\n            token,\n            'getRate'\n          );\n          poolMulticaller.call(\n            `tokenRates[${i}]`,\n            poolAddress,\n            'getTokenRate',\n            [token]\n          );\n          poolMulticaller.call(\n            `linearPools.${token}.mainToken.address`,\n            token,\n            'getMainToken'\n          );\n          poolMulticaller.call(\n            `linearPools.${token}.mainToken.index`,\n            token,\n            'getMainIndex'\n          );\n          poolMulticaller.call(\n            `linearPools.${token}.wrappedToken.address`,\n            token,\n            'getWrappedToken'\n          );\n          poolMulticaller.call(\n            `linearPools.${token}.wrappedToken.index`,\n            token,\n            'getWrappedIndex'\n          );\n          poolMulticaller.call(\n            `linearPools.${token}.wrappedToken.rate`,\n            token,\n            'getWrappedTokenRate'\n          );\n        });\n      }\n    }\n\n    result = await poolMulticaller.execute(result);\n\n    if (isDeep(pool) && result.linearPools) {\n      const wrappedTokensMap: Record<string, string> = {};\n\n      Object.keys(result.linearPools).forEach(address => {\n        if (!result.linearPools) return;\n        const linearPool: RawLinearPoolData = result.linearPools[address];\n\n        vaultMultiCaller.call(\n          `linearPools.${address}.tokenData`,\n          this.address,\n          'getPoolTokens',\n          [linearPool.id]\n        );\n\n        wrappedTokensMap[address] = linearPool.wrappedToken.address;\n      });\n\n      Object.entries(wrappedTokensMap).forEach(([address, wrappedToken]) => {\n        // The method to fetch the unwrapped asset of a linear pool can be\n        // different depending on if it's an ERC4626 or StaticAToken interface.\n        // Here we just try both methods and merge the result in formatting.\n        poolMulticaller.call(\n          `linearPools.${address}.unwrappedTokenAddress`,\n          wrappedToken,\n          'ATOKEN'\n        );\n        poolMulticaller.call(\n          `linearPools.${address}.unwrappedERC4626Address`,\n          wrappedToken,\n          'asset'\n        );\n\n        poolMulticaller.call(\n          `linearPools.${address}.totalSupply`,\n          address,\n          'getVirtualSupply'\n        );\n      });\n\n      result = await poolMulticaller.execute(result);\n    }\n\n    vaultMultiCaller.call('poolTokens', this.address, 'getPoolTokens', [id]);\n    result = await vaultMultiCaller.execute(result);\n\n    return this.formatPoolData(result, type, tokens, poolAddress);\n  }\n\n  public formatPoolData(\n    rawData: RawOnchainPoolData,\n    type: PoolType,\n    tokens: TokenInfoMap,\n    poolAddress: string\n  ): OnchainPoolData {\n    const poolData = <OnchainPoolData>{};\n\n    // Filter out pre-minted BPT token if exists\n    const validTokens = Object.keys(tokens).filter(\n      address => !isSameAddress(address, poolAddress)\n    );\n    tokens = pick(tokens, validTokens);\n\n    const normalizedWeights = this.normalizeWeights(\n      rawData?.weights || [],\n      type,\n      tokens\n    );\n\n    poolData.tokens = this.formatPoolTokens(\n      rawData.poolTokens,\n      tokens,\n      normalizedWeights,\n      poolAddress\n    );\n\n    poolData.amp = '0';\n    if (rawData?.amp) {\n      poolData.amp = rawData.amp.value.div(rawData.amp.precision).toString();\n    }\n\n    poolData.swapEnabled = true;\n    if (rawData.swapEnabled !== undefined) {\n      poolData.swapEnabled = rawData.swapEnabled;\n    }\n\n    if (rawData?.linearPools) {\n      poolData.linearPools = this.formatLinearPools(rawData.linearPools);\n    }\n\n    if (rawData.tokenRates) {\n      poolData.tokenRates = rawData.tokenRates.map(rate =>\n        formatUnits(rate.toString(), 18)\n      );\n    }\n\n    poolData.totalSupply = formatUnits(rawData.totalSupply, rawData.decimals);\n    poolData.decimals = rawData.decimals;\n    poolData.swapFee = formatUnits(rawData.swapFee, 18);\n\n    return poolData;\n  }\n\n  private formatPoolTokens(\n    poolTokens: RawPoolTokens,\n    tokenInfo: TokenInfoMap,\n    weights: number[],\n    poolAddress: string\n  ): OnchainTokenDataMap {\n    const tokens = <OnchainTokenDataMap>{};\n\n    poolTokens.tokens.forEach((token, i) => {\n      const tokenBalance = poolTokens.balances[i];\n      const decimals = tokenInfo[token]?.decimals;\n      tokens[token.toLowerCase()] = {\n        decimals,\n        balance: formatUnits(tokenBalance, decimals),\n        weight: weights[i],\n        symbol: tokenInfo[token]?.symbol,\n        name: tokenInfo[token]?.name,\n        logoURI: tokenInfo[token]?.logoURI,\n      };\n    });\n\n    // Remove pre-minted BPT\n    delete tokens[poolAddress.toLowerCase()];\n\n    return tokens;\n  }\n\n  private formatLinearPools(\n    linearPools: RawLinearPoolDataMap\n  ): LinearPoolDataMap {\n    const _linearPools = <LinearPoolDataMap>{};\n\n    Object.keys(linearPools).forEach(address => {\n      const {\n        id,\n        mainToken,\n        wrappedToken,\n        priceRate,\n        unwrappedTokenAddress,\n        unwrappedERC4626Address,\n        tokenData,\n        totalSupply,\n      } = linearPools[address];\n\n      const unwrappedAddress =\n        unwrappedTokenAddress ||\n        unwrappedERC4626Address ||\n        wrappedToken.address;\n\n      _linearPools[address.toLowerCase()] = {\n        id,\n        priceRate: formatUnits(priceRate.toString(), 18),\n        mainToken: {\n          address: getAddress(mainToken.address),\n          index: mainToken.index.toNumber(),\n          balance: tokenData.balances[mainToken.index.toNumber()].toString(),\n        },\n        wrappedToken: {\n          address: getAddress(wrappedToken.address),\n          index: wrappedToken.index.toNumber(),\n          balance: tokenData.balances[wrappedToken.index.toNumber()].toString(),\n          priceRate: formatUnits(wrappedToken.rate, 18),\n        },\n        unwrappedTokenAddress: unwrappedAddress,\n        totalSupply: formatUnits(totalSupply, 18),\n      };\n    });\n\n    return _linearPools;\n  }\n\n  public normalizeWeights(\n    weights: BigNumber[],\n    type: PoolType,\n    tokens: TokenInfoMap\n  ): number[] {\n    if (isWeightedLike(type)) {\n      // toNormalizedWeights returns weights as 18 decimal fixed point\n      return toNormalizedWeights(weights).map(w => Number(formatUnits(w, 18)));\n    } else if (isStableLike(type)) {\n      const tokensList = Object.values(tokens);\n      return tokensList.map(() => 1 / tokensList.length);\n    } else {\n      return [];\n    }\n  }\n\n  public get address(): string {\n    return this.service.config.addresses.vault;\n  }\n}\n","import { BigNumber } from '@ethersproject/bignumber';\nimport { TransactionResponse } from '@ethersproject/providers';\nimport { WalletProvider } from '@/dependencies/wallets/Web3Provider';\nimport { formatUnits } from '@ethersproject/units';\nimport { parseUnits } from '@ethersproject/units';\n\nimport { toJsTimestamp, toUtcTime } from '@/composables/useTime';\nimport veBalAbi from '@/lib/abi/veBalAbi.json';\n\nimport Service from '../balancer-contracts.service';\nimport { TransactionBuilder } from '@/services/web3/transactions/transaction.builder';\nimport { ContractInterface } from 'ethers';\nimport { getOldMulticaller } from '@/dependencies/OldMulticaller';\n\nexport type VeBalLockInfo = {\n  lockedEndDate: number;\n  lockedAmount: string;\n  totalSupply: string;\n  epoch: string;\n  hasExistingLock: boolean;\n  isExpired: boolean;\n};\n\nexport type VeBalLockInfoResult = {\n  locked: BigNumber[];\n  epoch: BigNumber;\n  totalSupply: BigNumber;\n};\n\nexport default class VeBAL {\n  service: Service;\n\n  constructor(service: Service) {\n    this.service = service;\n  }\n\n  private parseDate(date: string) {\n    return (toUtcTime(new Date(date)) / 1000).toString();\n  }\n\n  public async getLockInfo(account: string): Promise<VeBalLockInfo> {\n    const Multicaller = getOldMulticaller();\n    const veBalMulticaller = new Multicaller(\n      this.service.config.key,\n      this.service.provider,\n      veBalAbi\n    );\n\n    veBalMulticaller.call('locked', this.address, 'locked', [account]);\n    veBalMulticaller.call('epoch', this.address, 'epoch');\n    veBalMulticaller.call('totalSupply', this.address, 'totalSupply()');\n\n    const result = await veBalMulticaller.execute<VeBalLockInfoResult>();\n\n    return this.formatLockInfo(result);\n  }\n\n  public formatLockInfo(lockInfo: VeBalLockInfoResult) {\n    const [lockedAmount, lockedEndDate] = lockInfo.locked;\n\n    const hasExistingLock = lockedAmount.gt(0);\n    const lockedEndDateNormalised = toJsTimestamp(lockedEndDate.toNumber());\n    const isExpired = hasExistingLock && Date.now() > lockedEndDateNormalised;\n\n    return {\n      lockedEndDate: lockedEndDateNormalised,\n      lockedAmount: formatUnits(lockedAmount, 18),\n      totalSupply: formatUnits(lockInfo.totalSupply, 18),\n      epoch: lockInfo.epoch.toString(),\n      hasExistingLock,\n      isExpired,\n    };\n  }\n\n  public async createLock(\n    userProvider: WalletProvider,\n    lockAmount: string,\n    lockEndDate: string\n  ): Promise<TransactionResponse> {\n    const txBuilder = new TransactionBuilder(userProvider.getSigner());\n    return await txBuilder.contract.sendTransaction({\n      contractAddress: this.address,\n      abi: veBalAbi as ContractInterface,\n      action: 'create_lock',\n      params: [parseUnits(lockAmount, 18), this.parseDate(lockEndDate)],\n    });\n  }\n\n  public async increaseLock(\n    userProvider: WalletProvider,\n    lockAmount: string\n  ): Promise<TransactionResponse> {\n    const txBuilder = new TransactionBuilder(userProvider.getSigner());\n    return await txBuilder.contract.sendTransaction({\n      contractAddress: this.address,\n      abi: veBalAbi as ContractInterface,\n      action: 'increase_amount',\n      params: [parseUnits(lockAmount, 18)],\n    });\n  }\n\n  public async extendLock(\n    userProvider: WalletProvider,\n    lockEndDate: string\n  ): Promise<TransactionResponse> {\n    const txBuilder = new TransactionBuilder(userProvider.getSigner());\n    return await txBuilder.contract.sendTransaction({\n      contractAddress: this.address,\n      abi: veBalAbi as ContractInterface,\n      action: 'increase_unlock_time',\n      params: [this.parseDate(lockEndDate)],\n    });\n  }\n\n  public async unlock(\n    userProvider: WalletProvider\n  ): Promise<TransactionResponse> {\n    const txBuilder = new TransactionBuilder(userProvider.getSigner());\n    return await txBuilder.contract.sendTransaction({\n      contractAddress: this.address,\n      abi: veBalAbi as ContractInterface,\n      action: 'withdraw',\n    });\n  }\n\n  public get address(): string {\n    return this.service.config.addresses.veBAL;\n  }\n}\n","import {\n  InvestmentPool__factory,\n  StablePool__factory,\n  WeightedPool__factory,\n} from '@balancer-labs/typechain';\nimport { JsonRpcProvider } from '@ethersproject/providers';\nimport ERC20_ABI from '@/lib/abi/ERC20.json';\nimport IERC4626 from '@/lib/abi/IERC4626.json';\nimport LinearPoolAbi from '@/lib/abi/LinearPool.json';\nimport StablePhantomPool from '@/lib/abi/StablePhantomPool.json';\nimport StaticATokenLMAbi from '@/lib/abi/StaticATokenLM.json';\n// eslint-disable-next-line no-restricted-imports\nimport { balancer } from '@/lib/balancer.sdk';\n// import { getBalancerSDK } from '@/dependencies/balancer-sdk';\nimport { Config } from '@/lib/config/types';\nimport { configService as _configService } from '@/services/config/config.service';\nimport { rpcProviderService as _rpcProviderService } from '@/services/rpc-provider/rpc-provider.service';\nimport Vault from './contracts/vault';\nimport veBAL from './contracts/veBAL';\n\nexport default class BalancerContractsService {\n  vault: Vault;\n  config: Config;\n  provider: JsonRpcProvider;\n  veBAL: veBAL;\n\n  constructor(\n    readonly configService = _configService,\n    readonly rpcProviderService = _rpcProviderService,\n    // TODO: Fix affected tests by refactoring export balancerContractsService\n    // readonly sdk = getBalancerSDK()\n    readonly sdk = balancer\n  ) {\n    this.provider = this.rpcProviderService.jsonProvider;\n    this.config = this.configService.network;\n\n    // Init contracts\n    this.vault = new Vault(this);\n    this.veBAL = new veBAL(this);\n  }\n\n  // Combine all the ABIs and remove duplicates\n  public get allPoolABIs() {\n    return Object.values(\n      Object.fromEntries(\n        [\n          ...WeightedPool__factory.abi,\n          ...StablePool__factory.abi,\n          ...InvestmentPool__factory.abi,\n          ...StablePhantomPool,\n          ...LinearPoolAbi,\n          ...StaticATokenLMAbi,\n          ...ERC20_ABI,\n          ...IERC4626,\n        ].map(row => [row.name, row])\n      )\n    );\n  }\n}\n\nexport const balancerContractsService = new BalancerContractsService();\n","import { computed, reactive } from 'vue';\nimport { useQuery, UseQueryOptions } from '@tanstack/vue-query';\n\nimport { balancerContractsService } from '@/services/balancer/contracts/balancer-contracts.service';\nimport { VeBalLockInfo } from '@/services/balancer/contracts/contracts/veBAL';\nimport useWeb3 from '@/services/web3/useWeb3';\n\nimport useNetwork from '../useNetwork';\nimport { isVeBalSupported } from '../useVeBAL';\n\n/**\n * TYPES\n */\ntype QueryResponse = VeBalLockInfo;\ntype QueryOptions = UseQueryOptions<QueryResponse>;\n\nexport default function useVeBalQuery(options: QueryOptions = {}) {\n  /**\n   * COMPOSABLES\n   */\n  const { account, isWalletReady } = useWeb3();\n  const { networkId } = useNetwork();\n  /**\n   * COMPUTED\n   */\n  const enabled = computed(() => isWalletReady.value && isVeBalSupported.value);\n\n  const queryFn = () =>\n    balancerContractsService.veBAL.getLockInfo(account.value);\n\n  const queryOptions = reactive({\n    enabled,\n    ...options,\n  });\n\n  return useQuery<QueryResponse>(\n    reactive(['tokens', 'veBAL', { networkId, account }]),\n    queryFn,\n    queryOptions as QueryOptions\n  );\n}\n"],"names":["ProtocolFeesCollector","vault","__publicField","Contract","ProtocolFeesCollectorAbi","scaledPercentage","formatUnits","error","Vault","service","instanceABI","VaultAbi","pool","id","type","tokens","poolAddress","getAddress","result","Multicaller","getOldMulticaller","vaultMultiCaller","Vault__factory","poolMulticaller","isWeightedLike","isSwappingHaltable","isStableLike","isComposableStableLike","isComposableStable","isDeep","token","i","wrappedTokensMap","address","linearPool","wrappedToken","rawData","poolData","validTokens","isSameAddress","pick","normalizedWeights","rate","poolTokens","tokenInfo","weights","tokenBalance","decimals","_a","_b","_c","_d","linearPools","_linearPools","mainToken","priceRate","unwrappedTokenAddress","unwrappedERC4626Address","tokenData","totalSupply","unwrappedAddress","toNormalizedWeights","w","tokensList","VeBAL","date","toUtcTime","account","veBalMulticaller","veBalAbi","lockInfo","lockedAmount","lockedEndDate","hasExistingLock","lockedEndDateNormalised","toJsTimestamp","isExpired","userProvider","lockAmount","lockEndDate","TransactionBuilder","parseUnits","BalancerContractsService","configService","_configService","rpcProviderService","_rpcProviderService","sdk","balancer","veBAL","WeightedPool__factory","StablePool__factory","InvestmentPool__factory","StablePhantomPool","LinearPoolAbi","StaticATokenLMAbi","ERC20_ABI","IERC4626","row","balancerContractsService","useVeBalQuery","options","isWalletReady","useWeb3","networkId","useNetwork","enabled","computed","isVeBalSupported","queryFn","queryOptions","reactive","useQuery"],"mappings":"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"}