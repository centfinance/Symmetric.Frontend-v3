{"version":3,"file":"usePoolsQuery-5de67548.js","sources":["../../node_modules/@tanstack/query-core/build/lib/infiniteQueryBehavior.mjs","../../node_modules/@tanstack/query-core/build/lib/infiniteQueryObserver.mjs","../../node_modules/@tanstack/vue-query/build/lib/useInfiniteQuery.mjs","../../src/composables/queries/usePoolsQuery.ts"],"sourcesContent":["function infiniteQueryBehavior() {\n  return {\n    onFetch: context => {\n      context.fetchFn = () => {\n        var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;\n\n        const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;\n        const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;\n        const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;\n        const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'forward';\n        const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'backward';\n        const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];\n        const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];\n        let newPageParams = oldPageParams;\n        let cancelled = false;\n\n        const addSignalProperty = object => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              var _context$signal;\n\n              if ((_context$signal = context.signal) != null && _context$signal.aborted) {\n                cancelled = true;\n              } else {\n                var _context$signal2;\n\n                (_context$signal2 = context.signal) == null ? void 0 : _context$signal2.addEventListener('abort', () => {\n                  cancelled = true;\n                });\n              }\n\n              return context.signal;\n            }\n          });\n        }; // Get query function\n\n\n        const queryFn = context.options.queryFn || (() => Promise.reject('Missing queryFn'));\n\n        const buildNewPages = (pages, param, page, previous) => {\n          newPageParams = previous ? [param, ...newPageParams] : [...newPageParams, param];\n          return previous ? [page, ...pages] : [...pages, page];\n        }; // Create function to fetch a page\n\n\n        const fetchPage = (pages, manual, param, previous) => {\n          if (cancelled) {\n            return Promise.reject('Cancelled');\n          }\n\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages);\n          }\n\n          const queryFnContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            meta: context.options.meta\n          };\n          addSignalProperty(queryFnContext);\n          const queryFnResult = queryFn(queryFnContext);\n          const promise = Promise.resolve(queryFnResult).then(page => buildNewPages(pages, param, page, previous));\n          return promise;\n        };\n\n        let promise; // Fetch first page?\n\n        if (!oldPages.length) {\n          promise = fetchPage([]);\n        } // Fetch next page?\n        else if (isFetchingNextPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getNextPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param);\n        } // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getPreviousPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param, true);\n        } // Refetch pages\n        else {\n          newPageParams = [];\n          const manual = typeof context.options.getNextPageParam === 'undefined';\n          const shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true; // Fetch first page\n\n          promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0])); // Fetch remaining pages\n\n          for (let i = 1; i < oldPages.length; i++) {\n            promise = promise.then(pages => {\n              const shouldFetchNextPage = refetchPage && oldPages[i] ? refetchPage(oldPages[i], i, oldPages) : true;\n\n              if (shouldFetchNextPage) {\n                const param = manual ? oldPageParams[i] : getNextPageParam(context.options, pages);\n                return fetchPage(pages, manual, param);\n              }\n\n              return Promise.resolve(buildNewPages(pages, oldPageParams[i], oldPages[i]));\n            });\n          }\n        }\n\n        const finalPromise = promise.then(pages => ({\n          pages,\n          pageParams: newPageParams\n        }));\n        return finalPromise;\n      };\n    }\n  };\n}\nfunction getNextPageParam(options, pages) {\n  return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);\n}\nfunction getPreviousPageParam(options, pages) {\n  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);\n}\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasNextPage(options, pages) {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    const nextPageParam = getNextPageParam(options, pages);\n    return typeof nextPageParam !== 'undefined' && nextPageParam !== null && nextPageParam !== false;\n  }\n\n  return;\n}\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasPreviousPage(options, pages) {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    const previousPageParam = getPreviousPageParam(options, pages);\n    return typeof previousPageParam !== 'undefined' && previousPageParam !== null && previousPageParam !== false;\n  }\n\n  return;\n}\n\nexport { getNextPageParam, getPreviousPageParam, hasNextPage, hasPreviousPage, infiniteQueryBehavior };\n//# sourceMappingURL=infiniteQueryBehavior.mjs.map\n","import { QueryObserver } from './queryObserver.mjs';\nimport { infiniteQueryBehavior, hasNextPage, hasPreviousPage } from './infiniteQueryBehavior.mjs';\n\nclass InfiniteQueryObserver extends QueryObserver {\n  // Type override\n  // Type override\n  // Type override\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(client, options) {\n    super(client, options);\n  }\n\n  bindMethods() {\n    super.bindMethods();\n    this.fetchNextPage = this.fetchNextPage.bind(this);\n    this.fetchPreviousPage = this.fetchPreviousPage.bind(this);\n  }\n\n  setOptions(options, notifyOptions) {\n    super.setOptions({ ...options,\n      behavior: infiniteQueryBehavior()\n    }, notifyOptions);\n  }\n\n  getOptimisticResult(options) {\n    options.behavior = infiniteQueryBehavior();\n    return super.getOptimisticResult(options);\n  }\n\n  fetchNextPage({\n    pageParam,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        fetchMore: {\n          direction: 'forward',\n          pageParam\n        }\n      }\n    });\n  }\n\n  fetchPreviousPage({\n    pageParam,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        fetchMore: {\n          direction: 'backward',\n          pageParam\n        }\n      }\n    });\n  }\n\n  createResult(query, options) {\n    var _state$fetchMeta, _state$fetchMeta$fetc, _state$fetchMeta2, _state$fetchMeta2$fet, _state$data, _state$data2;\n\n    const {\n      state\n    } = query;\n    const result = super.createResult(query, options);\n    const {\n      isFetching,\n      isRefetching\n    } = result;\n    const isFetchingNextPage = isFetching && ((_state$fetchMeta = state.fetchMeta) == null ? void 0 : (_state$fetchMeta$fetc = _state$fetchMeta.fetchMore) == null ? void 0 : _state$fetchMeta$fetc.direction) === 'forward';\n    const isFetchingPreviousPage = isFetching && ((_state$fetchMeta2 = state.fetchMeta) == null ? void 0 : (_state$fetchMeta2$fet = _state$fetchMeta2.fetchMore) == null ? void 0 : _state$fetchMeta2$fet.direction) === 'backward';\n    return { ...result,\n      fetchNextPage: this.fetchNextPage,\n      fetchPreviousPage: this.fetchPreviousPage,\n      hasNextPage: hasNextPage(options, (_state$data = state.data) == null ? void 0 : _state$data.pages),\n      hasPreviousPage: hasPreviousPage(options, (_state$data2 = state.data) == null ? void 0 : _state$data2.pages),\n      isFetchingNextPage,\n      isFetchingPreviousPage,\n      isRefetching: isRefetching && !isFetchingNextPage && !isFetchingPreviousPage\n    };\n  }\n\n}\n\nexport { InfiniteQueryObserver };\n//# sourceMappingURL=infiniteQueryObserver.mjs.map\n","import { InfiniteQueryObserver } from '@tanstack/query-core';\nimport { useBaseQuery } from './useBaseQuery.mjs';\n\nfunction useInfiniteQuery(arg1, arg2, arg3) {\n  const result = useBaseQuery(InfiniteQueryObserver, arg1, arg2, arg3);\n  return { ...result,\n    fetchNextPage: result.fetchNextPage.value,\n    fetchPreviousPage: result.fetchPreviousPage.value,\n    refetch: result.refetch.value,\n    remove: result.remove.value\n  };\n}\n\nexport { useInfiniteQuery };\n//# sourceMappingURL=useInfiniteQuery.mjs.map\n","import { useInfiniteQuery, UseInfiniteQueryOptions } from '@tanstack/vue-query';\n\nimport { POOLS } from '@/constants/pools';\nimport QUERY_KEYS from '@/constants/queryKeys';\nimport { Pool } from '@/services/pool/types';\n\nimport useNetwork from '../useNetwork';\nimport { useTokens } from '@/providers/tokens.provider';\nimport { configService } from '@/services/config/config.service';\nimport { GraphQLArgs, PoolsRepositoryFetchOptions } from '@balancer-labs/sdk';\nimport { getPoolsFallbackRepository } from '@/dependencies/PoolsFallbackRepository';\nimport { PoolDecorator } from '@/services/pool/decorators/pool.decorator';\nimport { flatten } from 'lodash';\nimport { tokenTreeLeafs } from '../usePoolHelpers';\nimport { balancerSubgraphService } from '@/services/balancer/subgraph/balancer-subgraph.service';\nimport { balancerAPIService } from '@/services/balancer/api/balancer-api.service';\nimport { poolsStoreService } from '@/services/pool/pools-store.service';\nimport { isBalancerApiDefined } from '@/lib/utils/balancer/api';\nimport { bnum } from '@/lib/utils';\nimport { PoolAttributeFilter, PoolFilterOptions } from '@/types/pools';\nimport { weeksAgoInSecs } from '../useTime';\n\ntype PoolsQueryResponse = {\n  pools: Pool[];\n  skip?: number;\n};\n\nexport default function usePoolsQuery(\n  filterOptions: PoolFilterOptions,\n  options: UseInfiniteQueryOptions<PoolsQueryResponse> = { enabled: true },\n  shouldInjectTokens = true\n) {\n  /**\n   * COMPOSABLES\n   */\n  const { injectTokens, tokens: tokenMeta } = useTokens();\n  const { networkId } = useNetwork();\n  let poolsRepository = initializePoolsRepository();\n\n  /**\n   * METHODS\n   */\n\n  function initializePoolsRepository() {\n    const FallbackRepository = getPoolsFallbackRepository();\n    const fallbackRepository = new FallbackRepository(buildRepositories(), {\n      timeout: 30 * 1000,\n    });\n    return fallbackRepository;\n  }\n\n  function initializeDecoratedAPIRepository() {\n    return {\n      fetch: async (options: PoolsRepositoryFetchOptions): Promise<Pool[]> => {\n        const pools = await balancerAPIService.pools.get(getQueryArgs(options));\n\n        if (shouldInjectTokens) {\n          const tokens = flatten(\n            pools.map(pool => [\n              ...pool.tokensList,\n              ...tokenTreeLeafs(pool.tokens),\n              pool.address,\n            ])\n          );\n          injectTokens(tokens);\n        }\n\n        return pools;\n      },\n    };\n  }\n\n  function initializeDecoratedSubgraphRepository() {\n    return {\n      fetch: async (options: PoolsRepositoryFetchOptions): Promise<Pool[]> => {\n        const pools = await balancerSubgraphService.pools.get(\n          getQueryArgs(options)\n        );\n        const poolDecorator = new PoolDecorator(pools);\n        let decoratedPools = await poolDecorator.decorate(tokenMeta.value);\n\n        if (shouldInjectTokens) {\n          const tokens = flatten(\n            pools.map(pool => [\n              ...pool.tokensList,\n              ...tokenTreeLeafs(pool.tokens),\n              pool.address,\n            ])\n          );\n          await injectTokens(tokens);\n        }\n\n        decoratedPools = await poolDecorator.reCalculateTotalLiquidities();\n\n        return decoratedPools;\n      },\n    };\n  }\n\n  function buildRepositories() {\n    const repositories: any[] = [];\n    if (isBalancerApiDefined) {\n      const balancerApiRepository = initializeDecoratedAPIRepository();\n      repositories.push(balancerApiRepository);\n    }\n    const subgraphRepository = initializeDecoratedSubgraphRepository();\n    repositories.push(subgraphRepository);\n\n    return repositories;\n  }\n\n  function getQueryArgs(options: PoolsRepositoryFetchOptions): GraphQLArgs {\n    const { tokens, poolIds, poolTypes, sortField, poolAttributes } =\n      filterOptions.value;\n    const hasPoolIdFilters = !!poolIds?.length && poolIds?.length > 0;\n    const hasPoolTypeFilters = !!poolTypes?.length;\n    const hasPoolAttributeFilters = !!poolAttributes?.length;\n\n    const tokensListFilterOperation = filterOptions.value.useExactTokens\n      ? 'eq'\n      : 'contains';\n\n    const tokenListFormatted =\n      tokens?.map(address => address.toLowerCase()) || [];\n\n    const orderBy = isBalancerApiDefined\n      ? sortField || 'totalLiquidity'\n      : 'totalLiquidity';\n\n    const queryArgs: GraphQLArgs = {\n      chainId: configService.network.chainId,\n      orderBy,\n      orderDirection: 'desc',\n      where: {\n        tokensList: { [tokensListFilterOperation]: tokenListFormatted },\n        poolType: { in: POOLS.IncludedPoolTypes },\n        totalShares: { gt: 0.00001 },\n        id: { not_in: POOLS.BlockList },\n      },\n    };\n\n    if (queryArgs.where && hasPoolTypeFilters && !!poolTypes?.length) {\n      queryArgs.where.poolType = {\n        in: poolTypes,\n      };\n    }\n\n    if (queryArgs.where && hasPoolIdFilters) {\n      queryArgs.where.id = { in: filterOptions.value.poolIds };\n    }\n    if (options.first) {\n      queryArgs.first = filterOptions.value.first || options.first;\n    }\n    if (options.skip) {\n      queryArgs.skip = options.skip;\n    }\n\n    if (\n      queryArgs.where &&\n      hasPoolAttributeFilters &&\n      poolAttributes.includes(PoolAttributeFilter.New)\n    ) {\n      queryArgs.where.createTime = { gt: weeksAgoInSecs(1) };\n    }\n\n    return queryArgs;\n  }\n\n  function getFetchOptions(pageParam = 0): PoolsRepositoryFetchOptions {\n    const fetchArgs: PoolsRepositoryFetchOptions = {};\n\n    fetchArgs.first = filterOptions.value.pageSize || POOLS.Pagination.PerPage;\n\n    if (pageParam && pageParam > 0) {\n      fetchArgs.skip = pageParam;\n    }\n\n    return fetchArgs;\n  }\n\n  function customSort(pools: Pool[]): Pool[] {\n    const poolsSortField = filterOptions.value.sortField || 'totalLiquidity';\n\n    if (poolsSortField === 'totalLiquidity') return pools;\n\n    if (poolsSortField === 'apr') {\n      return pools.sort((a, b) => {\n        const aprA = a?.apr?.max ?? 0;\n        const aprB = b?.apr?.max ?? 0;\n        return aprB - aprA;\n      });\n    } else if (poolsSortField === 'volume') {\n      return pools.sort((a, b) => {\n        const volumeA = bnum(a?.totalSwapVolume ?? 0);\n        const volumeB = bnum(b?.totalSwapVolume ?? 0);\n        return volumeB.minus(volumeA).toNumber();\n      });\n    }\n\n    return pools;\n  }\n\n  /**\n   *  When filterTokens changes, re-initialize the repositories as their queries\n   *  need to change to filter for those tokens\n   */\n  watch(\n    filterOptions,\n    () => {\n      poolsRepository = initializePoolsRepository();\n      poolsStoreService.setPools([]);\n    },\n    { deep: true }\n  );\n\n  /**\n   * QUERY KEY\n   */\n  const queryKey = QUERY_KEYS.Pools.All(networkId, filterOptions);\n\n  /**\n   * QUERY FUNCTION\n   */\n  const queryFn = async ({ pageParam = 0 }) => {\n    if (\n      !options.enabled ||\n      (isRef(options.enabled) && !options.enabled.value)\n    ) {\n      return {\n        pools: [],\n        skip: 0,\n      };\n    }\n    const fetchOptions = getFetchOptions(pageParam);\n    const skip = (fetchOptions.first || 0) + (fetchOptions.skip || 0);\n    try {\n      let pools: Pool[] = await poolsRepository.fetch(fetchOptions);\n      if (!isBalancerApiDefined) pools = customSort(pools);\n\n      poolsStoreService.addPools(pools);\n\n      return {\n        pools,\n        skip,\n      };\n    } catch (e) {\n      const savedPools = poolsStoreService.pools.value;\n      if (savedPools && savedPools.length > 0) {\n        return { pools: savedPools, skip };\n      }\n      throw e;\n    }\n  };\n\n  options.getNextPageParam = (lastPage: PoolsQueryResponse) =>\n    lastPage.skip || 0;\n\n  return useInfiniteQuery<PoolsQueryResponse>(queryKey, queryFn, options);\n}\n"],"names":["infiniteQueryBehavior","context","_context$fetchOptions","_context$fetchOptions2","_context$fetchOptions3","_context$fetchOptions4","_context$state$data","_context$state$data2","refetchPage","fetchMore","pageParam","isFetchingNextPage","isFetchingPreviousPage","oldPages","oldPageParams","newPageParams","cancelled","addSignalProperty","object","_context$signal","_context$signal2","queryFn","buildNewPages","pages","param","page","previous","fetchPage","manual","queryFnContext","queryFnResult","promise","getNextPageParam","getPreviousPageParam","i","options","hasNextPage","nextPageParam","hasPreviousPage","previousPageParam","InfiniteQueryObserver","QueryObserver","client","notifyOptions","query","_state$fetchMeta","_state$fetchMeta$fetc","_state$fetchMeta2","_state$fetchMeta2$fet","_state$data","_state$data2","state","result","isFetching","isRefetching","useInfiniteQuery","arg1","arg2","arg3","useBaseQuery","usePoolsQuery","filterOptions","shouldInjectTokens","injectTokens","tokenMeta","useTokens","networkId","useNetwork","poolsRepository","initializePoolsRepository","FallbackRepository","getPoolsFallbackRepository","buildRepositories","initializeDecoratedAPIRepository","options2","pools","balancerAPIService","getQueryArgs","tokens","flatten","pool","tokenTreeLeafs","initializeDecoratedSubgraphRepository","balancerSubgraphService","poolDecorator","PoolDecorator","decoratedPools","repositories","isBalancerApiDefined","balancerApiRepository","subgraphRepository","poolIds","poolTypes","sortField","poolAttributes","hasPoolIdFilters","hasPoolTypeFilters","hasPoolAttributeFilters","tokensListFilterOperation","tokenListFormatted","address","orderBy","queryArgs","configService","POOLS","PoolAttributeFilter","weeksAgoInSecs","getFetchOptions","fetchArgs","customSort","poolsSortField","a","b","aprA","_a","_b","volumeA","bnum","watch","poolsStoreService","queryKey","QUERY_KEYS","isRef","fetchOptions","skip","e","savedPools","lastPage"],"mappings":"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"}